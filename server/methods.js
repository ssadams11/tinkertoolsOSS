// Generated by CoffeeScript 1.12.6
(function() {
  var escapeDollarSignInStrings;

  Meteor.startup(function() {});

  Meteor.methods({
    runScript: function(userID, serverURL, tinkerPopVersion, usingWebSockets, scriptName, script, bindings) {
      var args, e, final, length, loggingScript, response, resultJSON, resultString, sendScript;
      loggingScript = 'println "Executing script: [' + scriptName + '] "\n' + script;
      sendScript = encodeURIComponent(escapeDollarSignInStrings(script));
      if (userID && serverURL && script) {
        console.log("version =  ", tinkerPopVersion);
        if (tinkerPopVersion === '3') {
          args = {
            data: {
              gremlin: script,
              bindings: bindings
            },
            headers: {
              "Content-Type": 'application/json'
            }
          };
          console.log("bindings = ", JSON.stringify(bindings));
          console.log("script = ", loggingScript);
          try {
            response = HTTP.post(serverURL, args);
            return console.log("POST results = ", response);
          } catch (error) {
            e = error;
            return response = e.response;
          } finally {
            if ((response !== void 0) && response.statusCode && response.statusCode === 200) {
              resultString = response.content;
              resultString = resultString.replace(/(:[ ]?)\d{15,9999}/g, function(x) {
                var y;
                y = x.replace(/\D/g, '');
                return ': "' + y + '"';
              });
              resultJSON = JSON.parse(resultString);
              if (resultJSON === null) {
                resultJSON = {
                  results: [null],
                  success: '???',
                  queryTime: 'N/A'
                };
              }
              if (resultJSON.result === null) {
                length = 1;
                resultJSON.result = [null];
              } else {
                length = resultJSON.result.data.length;
                console.log('success:', resultJSON.status.code === 200, ' queryTime:', 'Not Available from Service', ' results.length:', length);
                final = {
                  results: resultJSON.result.data,
                  success: resultJSON.status.code === 200,
                  queryTime: 'Not Available from Service'
                };
                return final;
              }
            } else {
              return {
                results: response,
                success: 'Error',
                queryTime: 'N/A'
              };
            }
          }
        }
      }
    },
    getGraphsOnServer: function(serverURL) {
      var response;
      if (serverURL) {
        response = HTTP.get(serverURL + '/graphs');
        return response.data.graphs;
      } else {
        return [];
      }
    },
    removeScript: function(userID, serverURL, graphName, scriptName) {
      return Scripts.remove({
        userID: userID,
        serverURL: serverURL,
        graphName: graphName,
        scriptName: scriptName
      });
    },
    removeURL: function(userID, serverURL) {
      return Scripts.remove({
        userID: userID,
        serverURL: serverURL
      });
    },
    updateScript: function(selector, modifier) {
      return Scripts.update(selector, modifier);
    },
    getEntireGraph: function(serverURL, graphName) {
      var e, edges, es, g, nodes, resp, url, v, vs;
      url = serverURL + '/graphs/' + graphName + '/tp/gremlin?script=[g.V(),g.E()]';
      console.log(url);
      resp = HTTP.get(url);
      if (resp.data.success) {
        vs = resp.data.results[0];
        es = resp.data.results[1];
        nodes = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = vs.length; j < len; j++) {
            v = vs[j];
            results.push({
              id: String(v._id),
              x: chance.floating({
                min: 0,
                max: 100
              }),
              y: chance.floating({
                min: 0,
                max: 100
              }),
              size: 1
            });
          }
          return results;
        })();
        edges = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = es.length; j < len; j++) {
            e = es[j];
            results.push({
              id: String(e._id),
              label: e._label,
              source: String(e._outV),
              target: String(e._inV)
            });
          }
          return results;
        })();
        g = {
          nodes: nodes,
          edges: edges
        };
      } else {
        g = trigraph();
      }
      return g;
    },
    allUserIDs: function() {
      var all, allEntries, each, nodups;
      allEntries = Meteor.users.find({}).fetch();
      debugger;
      all = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = allEntries.length; j < len; j++) {
          each = allEntries[j];
          results.push(each.emails[0].address);
        }
        return results;
      })();
      nodups = all.filter(function(v, i, a) {
        return a.indexOf(v) === i;
      });
      if (nodups.length === 0) {
        return [];
      }
      return nodups;
    },
    deleteGraphFile: function(fileName) {
      var fs;
      fs = Meteor.npmRequire('fs');
      return fs.unlink(process.env.PWD + "/.private/graphs/" + fileName);
    },
    deleteGraphFiles: function(fileNames) {
      var fileName, fs, j, len, results;
      fs = Meteor.npmRequire('fs');
      results = [];
      for (j = 0, len = fileNames.length; j < len; j++) {
        fileName = fileNames[j];
        results.push(fs.unlink(process.env.PWD + "/.private/graphs/" + fileName));
      }
      return results;
    },
    fileExistsOnServer: function(serverAddress, fileName) {
      var e, request, response;
      request = 'http://' + serverAddress + "/exists/" + fileName;
      console.log("request", request);
      try {
        return response = HTTP.get(request);
      } catch (error) {
        e = error;
        return response = e.response;
      } finally {
        if (response.statusCode && response.statusCode === 200) {
          console.log("file exists!");
          return true;
        } else {
          console.log("file does not exist!");
          return false;
        }
      }
    },
    onceFileExistsOnServer: function(serverAddress, fileName) {
      var doesNotExist, e, request, response;
      request = 'http://' + serverAddress + "/exists/" + fileName;
      console.log("request", request);
      doesNotExist = true;
      while (doesNotExist) {
        try {
          response = HTTP.get(request);
        } catch (error) {
          e = error;
          response = e.response;
        } finally {
          if (response.statusCode && response.statusCode === 200) {
            console.log("file exists!");
            doesNotExist = false;
          } else {
            console.log("file does not exist! trying again");
          }
        }
      }
      return true;
    },
    onceFilesExistOnServer: function(serverAddress, fileNames) {
      var doesNotExist, e, fileName, j, len, request, response;
      for (j = 0, len = fileNames.length; j < len; j++) {
        fileName = fileNames[j];
        request = 'http://' + serverAddress + "/exists/" + fileName;
        console.log("request", request);
        doesNotExist = true;
        while (doesNotExist) {
          try {
            response = HTTP.get(request);
          } catch (error) {
            e = error;
            response = e.response;
            console.log('error=', response);
          } finally {
            if (response.statusCode && response.statusCode === 200) {
              console.log(fileName, "exists!");
              doesNotExist = false;
            } else {
              console.log(fileName, "does not exist! trying again");
            }
          }
        }
      }
      return true;
    },
    discoverTinkerPopVersionAt: function(serverURL) {
      return [serverURL, '3'];
    },
    getEnvironmentVariable: function(varName) {
      return process.env[varName];
    }
  });

  escapeDollarSignInStrings = function(script) {
    return script.replace(/\$/g, '\\$');
  };

}).call(this);

//# sourceMappingURL=methods.js.map
