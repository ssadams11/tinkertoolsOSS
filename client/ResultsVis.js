// Generated by CoffeeScript 1.12.6
(function() {
  var addEdgeToGraph, addElementsFromBindingsJSON, addInTheNeighbors, addVertToGraph, allHiddenEdgeIDs, allHiddenNodeIDs, allKeysInVerts, allObjectsInsideWithKeyValue, chunks, cloneElements, cloneSelections, cloneVertToGraph, deleteSelected, deleteSelections, dropSelections, edgesInside, expandSelections, expandSelections5, generateJSONBindingsForSelections, getLabelSets, growSelections, hideSelections1, hideSelections2, hideSelections3, hideSelections4, inputGremlinCodeForIngestion, inspectNone, inspectSelections, invertSelections, labelForVertex, pinSelections, popupDialogForElement, processResults, retrieveVerticesForIDs, scriptForGeneralIngestionFindOrCreate, selectAll, selectNeighborsToAdd, selectNone, shareGremlinCodeForIngestion, spawnAllToQuikVis, spawnHidden1, spawnHidden2, spawnHidden3, spawnHidden4, spawnTheseToQuikVis, spawnToQuikVis, titleForElement, unhideSelections1, unhideSelections2, unhideSelections3, unhideSelections4, unpinSelections, userPropertiesForElement, vertIDsInEdges, verticesInside;

  Template.ResultsVis.rendered = function() {
    var graph, j, len, node, oldLoc, positions, ref, ve, vn;
    Session.set('graphRenderingStatus', 'Rendering...');
    Session.set('keyForNodeLabel', "null");
    Session.set('useLabelPrefix', true);
    window.setUpVis();
    Session.set('graphRenderingStatus', 'Rendering...');
    graph = Session.get('graphToShow');
    Session.set('renderStartTime', moment().toDate());
    vn = new vis.DataSet(graph.nodes);
    ve = new vis.DataSet(graph.edges);
    window.visnetwork.setData({
      nodes: vn,
      edges: ve
    });
    getLabelSets();
    if (Session.get('positions')) {
      positions = Session.get('positions');
    } else {
      positions = {};
    }
    ref = graph.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = positions[node.id];
      if (oldLoc) {
        node.x = oldLoc.x;
        node.y = oldLoc.y;
        node.physics = false;
      }
    }
    return window.visnetwork.nodesHandler.body.data.nodes.update(graph.nodes);
  };

  Template.ResultsVis.helpers({
    vertexPropertyNames: function() {
      return Session.get('vertexPropertyNames');
    },
    vertexPropertyName: function() {
      return this;
    },
    vertexLabels: function() {
      if (window.visnetwork) {
        getLabelSets();
      }
      return Session.get('vertexLabelSet');
    },
    vertexLabel: function() {
      return this;
    },
    visWidth: function() {
      if (Session.get("visWidth")) {
        return Session.get("visWidth");
      } else {
        return 'auto';
      }
    },
    visHeight: function() {
      if (Session.get("visHeight")) {
        return Session.get("visHeight");
      } else {
        return '900px';
      }
    }
  });

  window.determineGraphToShow = function() {
    var bindings, edges, missingVIDs, request, script, startTime, v, vIDsInEdges, vIDsInResults, verts;
    Session.set('graphToShow', {
      nodes: [],
      edges: []
    });
    verts = verticesInside(Session.get('scriptResult'));
    verts = _.uniq(verts, function(item) {
      return item.id;
    });
    edges = edgesInside(Session.get('scriptResult'));
    addEdgesToGraphToShow(edges);
    addVertsToGraphToShow(verts);
    Session.set('elementsInResults', {
      vertices: verts,
      edges: edges
    });
    vIDsInEdges = vertIDsInEdges(edges);
    vIDsInResults = [];
    vIDsInResults = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = verts.length; j < len; j++) {
        v = verts[j];
        results1.push(v.id);
      }
      return results1;
    })();
    missingVIDs = _.difference(vIDsInEdges, vIDsInResults);
    if (missingVIDs.length === 0) {
      return setGraphToShow(verts, edges);
    }
    if (missingVIDs.length === 0) {
      return;
    }
    bindings = {
      vIDs: missingVIDs
    };
    script = 'vIDs.collect{each-> g.V(each).next()}';
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json, results;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            results = [];
          } else {
            results = json.result.data;
          }
          return addVertsToGraphToShow(results);
        }
      };
      request = {
        requestId: uuid["new"](),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in Vertex Retriever', script, bindings, function(error, result) {
        return addVertsToGraphToShow(result.results);
      });
    }
  };

  window.addVertsToGraphToShow = function(verts) {
    var gts, nodes, v;
    nodes = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = verts.length; j < len; j++) {
        v = verts[j];
        results1.push({
          id: String(v.id),
          label: labelForVertex(v, Session.get('keyForNodeLabel')),
          allowedToMoveX: true,
          allowedToMoveY: true,
          title: titleForElement(v),
          element: v
        });
      }
      return results1;
    })();
    if (window.visnetwork) {
      window.visnetwork.nodesHandler.body.data.nodes.update(nodes);
    }
    if ((Session.get('graphToShow')) === void 0) {
      Session.set('graphToShow', {
        nodes: [],
        edges: []
      });
    }
    gts = Session.get('graphToShow');
    gts.nodes = gts.nodes.concat(nodes);
    Session.set('graphToShow', gts);
    if (gts.nodes.length + gts.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.addEdgesToGraphToShow = function(edges) {
    var e, gts;
    edges = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = edges.length; j < len; j++) {
        e = edges[j];
        results1.push({
          id: String(e.id),
          label: e.label,
          from: String(e.outV),
          to: String(e.inV),
          title: titleForElement(e),
          element: e
        });
      }
      return results1;
    })();
    if (window.visnetwork) {
      window.visnetwork.edgesHandler.body.data.edges.update(edges);
    }
    if ((Session.get('graphToShow')) === void 0) {
      Session.set('graphToShow', {
        nodes: [],
        edges: []
      });
    }
    gts = Session.get('graphToShow');
    gts.edges = gts.edges.concat(edges);
    Session.set('graphToShow', gts);
    if (gts.edges.length + gts.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.setGraphToShow = function(verts, edges) {
    var e, g, keyForLabel, nodes, v;
    keyForLabel = Session.get('keyForNodeLabel');
    nodes = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = verts.length; j < len; j++) {
        v = verts[j];
        results1.push({
          id: String(v.id),
          label: labelForVertex(v, keyForLabel),
          allowedToMoveX: true,
          allowedToMoveY: true,
          title: titleForElement(v),
          element: v
        });
      }
      return results1;
    })();
    edges = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = edges.length; j < len; j++) {
        e = edges[j];
        results1.push({
          id: String(e.id),
          label: e.label,
          from: String(e.outV),
          to: String(e.inV),
          title: titleForElement(e),
          element: e
        });
      }
      return results1;
    })();
    g = {
      nodes: nodes,
      edges: edges
    };
    Session.set('graphToShow', g);
    if (g.nodes.length + g.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.randomizeLayout = function() {
    var g, j, len, node, ref;
    g = Session.get('graphToShow');
    ref = g.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      node.x = chance.floating({
        min: 0,
        max: 100
      });
      node.y = chance.floating({
        min: 0,
        max: 100
      });
    }
    return Session.set('graphToShow', g);
  };

  verticesInside = function(obj) {
    var verts;
    verts = [];
    allObjectsInsideWithKeyValue(verts, obj, 'type', 'vertex');
    return verts;
  };

  edgesInside = function(obj) {
    var edges;
    edges = [];
    allObjectsInsideWithKeyValue(edges, obj, 'type', 'edge');
    return edges;
  };

  vertIDsInEdges = function(edges) {
    var edge, edgeVertIDs, j, l, len, len1;
    edgeVertIDs = [];
    for (j = 0, len = edges.length; j < len; j++) {
      edge = edges[j];
      edgeVertIDs.push(edge.inV);
    }
    for (l = 0, len1 = edges.length; l < len1; l++) {
      edge = edges[l];
      edgeVertIDs.push(edge.outV);
    }
    return _.uniq(edgeVertIDs);
  };

  allObjectsInsideWithKeyValue = function(foundArray, obj, key, value) {
    var j, l, len, len1, okey, ref, subObj;
    if ((typeof obj === 'string') || (typeof obj === 'boolean') || (typeof obj === 'number') || (typeof obj === 'symbol') || (typeof obj === 'undefined') || (obj === null)) {
      return [];
    }
    if (Array.isArray(obj)) {
      for (j = 0, len = obj.length; j < len; j++) {
        subObj = obj[j];
        allObjectsInsideWithKeyValue(foundArray, subObj, key, value);
      }
    } else {
      if (obj[key] && obj[key] === value) {
        foundArray.push(obj);
      } else {
        ref = Object.keys(obj);
        for (l = 0, len1 = ref.length; l < len1; l++) {
          okey = ref[l];
          allObjectsInsideWithKeyValue(foundArray, obj[okey], key, value);
        }
      }
    }
    return [];
  };

  chunks = function(array, size) {
    var results;
    results = [];
    while (array.length) {
      results.push(array.splice(0, size));
    }
    return results;
  };

  retrieveVerticesForIDs = function(ids, callback) {
    var bindings, request, script, startTime;
    if (ids.length === 0) {
      return;
    }
    bindings = {
      vIDs: ids
    };
    script = 'vIDs.collect{each-> g.V(each).next()}';
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json, results;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            results = [];
          } else {
            results = json.result.data;
          }
          return callback(results);
        }
      };
      request = {
        requestId: uuid["new"](),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in Vertex Retriever', script, bindings, function(error, result) {
        return callback(result.results);
      });
    }
  };

  titleForElement = function(props) {
    var html, j, key, len, sortedKeys, tr, userProps, value;
    userProps = userPropertiesForElement(props);
    sortedKeys = _.sortBy(_.keys(userProps), function(e) {
      return e.toLocaleLowerCase();
    });
    html = '<div  class="vis-element-popup">';
    html = html + '<table style="width:200">';
    html = html + '<tr><th>' + props.type + ': </th><th>' + props.id + '</th><tr>';
    html = html + '<tr><td>label: </td><td>' + props.label + '</td><tr>';
    for (j = 0, len = sortedKeys.length; j < len; j++) {
      key = sortedKeys[j];
      value = userProps[key];
      tr = '<tr><td>' + key + ': </td><td>' + value + '</td></tr>';
      html = html + tr;
    }
    html = html + '</table>';
    html = html + '</div>';
    return html;
  };

  popupDialogForElement = function(localElement, elementType) {
    var addPropButton, cloneButton, copyPropButton, deletePropButton, html, id, j, key, len, logButton, pastePropButton, pinItButton, props, sortedKeys, tr, userProps, value;
    props = localElement.element;
    userProps = userPropertiesForElement(props);
    sortedKeys = _.sortBy(_.keys(userProps), function(e) {
      return e.toLocaleLowerCase();
    });
    id = props.id;
    html = '<div  class="vis-element-popup">';
    html = html + '<table style="width:100%" class="propTableForElementID' + id + '" name="' + elementType + '">';
    addPropButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Add property"><span class="glyphicon glyphicon-plus element-addProperty' + id + '"></span></a>';
    if (elementType === 'vertex') {
      cloneButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Clone this Vertex"><span class="clone-vertex' + id + '">Clone</span></a>';
    } else {
      cloneButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Clone this Edge"><span class="clone-edge' + id + '">Clone</span></a>';
    }
    deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
    copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
    pastePropButton = '<a href="#" class="btn btn-default" title="Paste property"><span class="glyphicon glyphicon-paste element-pasteProperty' + id + '"></span></a>';
    logButton = '<a href="#" class="btn btn-default" title="console.log the element"><span class="glyphicon glyphicon-share element-log' + id + '"></span></a>';
    pinItButton = '<input type="checkbox" class="vis-options-checkbox" id="pinItCheckBoxForId' + id + '" value="' + localElement.allowedToMoveX + '" onclick="pinVertex(\'' + id + '\',this.value)"><span class="glyphicon glyphicon-pushpin"></span></a>';
    html = html + '<tr><th>Property:  </th><th>Value</th><th style="width:50">' + addPropButton + pastePropButton + logButton + '</th><tr>';
    tr = '<tr><td>id:  </td><td>' + id + '</td><td style="width:50">' + pinItButton + '</td><tr>';
    html = html + tr;
    tr = '<tr><td>label:  </td><td>' + props.label + '</td><th style="width:50" id="' + id + '" value="' + elementType + '" name="' + key + '">' + cloneButton + '</th></tr>';
    html = html + tr;
    for (j = 0, len = sortedKeys.length; j < len; j++) {
      key = sortedKeys[j];
      value = userProps[key];
      tr = '<tr><td>' + key + ':  </td><td><input type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'.commitButtonForElementID' + id + '\').show()"></td><th style="width:50" id="' + id + '" value="' + elementType + '" name="' + key + '">' + deletePropButton + copyPropButton + '</th></tr>';
      html = html + tr;
    }
    html = html + '</table>';
    html = html + '<button type="button" style="display: none" class="commitButtonForElementID' + id + '" onclick="updateElementProps(\'' + id + '\',\'' + elementType + '\')">Commit changes</button>';
    html = html + '</div>';
    return html;
  };

  window.pinVertex = function(id, value) {
    var clientElement, nds, node, state;
    node = clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    state = $('#pinItCheckBoxForId' + node.id).first().is(':checked');
    nds = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
    return nds.update({
      id: node.id,
      physics: !state
    });
  };

  window.updateElementProps = function(id, elementType) {
    var clientElement, originalProps, props;
    if (elementType === 'vertex') {
      clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    } else {
      clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
    }
    props = {};
    originalProps = userPropertiesForElement(clientElement.element);
    $('.propForElementID' + id).each(function() {
      return props[$(this).attr("name")] = $(this).val();
    });
    return window.updatePropsForElement(elementType, id, props, originalProps);
  };

  window.updatePropsForElement = function(elementType, id, newProps, oldProps) {
    var bindings, changedProps, clientElement, j, key, keys2Delete, l, len, len1, len2, m, ref, ref1, ref2, request, script, startTime;
    $('.commitButtonForElementID' + id).hide();
    keys2Delete = [];
    ref = _.keys(oldProps);
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      if (newProps[key] === void 0) {
        keys2Delete.push(key);
      }
    }
    if (elementType === 'vertex') {
      clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    } else {
      clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
    }
    script = '';
    if (keys2Delete.length > 0) {
      if (elementType === "vertex") {
        script = script + 'keys2Delete.each { g.V(vID).properties(it).drop()}';
      } else {
        script = script + 'keys2Delete.each { g.E(vID).properties(it).drop()}';
      }
      bindings = {
        keys2Delete: keys2Delete,
        vID: id
      };
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, endTime, json, key2Delete, l, len1, results, results1;
          endTime = Date.now();
          console.log(msg);
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
            } else {
              results = json.result.data;
            }
            results1 = [];
            for (l = 0, len1 = keys2Delete.length; l < len1; l++) {
              key2Delete = keys2Delete[l];
              clientElement.element.properties = _.omit(clientElement.element.properties, key2Delete);
              clientElement.title = titleForElement(clientElement.element);
              if (elementType === 'vertex') {
                results1.push(window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []));
              } else {
                results1.push(window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []));
              }
            }
            return results1;
          }
        };
        request = {
          requestId: uuid["new"](),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: bindings,
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        window.socketToJanus.send(JSON.stringify(request));
      } else {
        Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property remover', script, bindings, function(error, result) {
          var key2Delete, l, len1, results1;
          if (result.success === true) {
            results1 = [];
            for (l = 0, len1 = keys2Delete.length; l < len1; l++) {
              key2Delete = keys2Delete[l];
              clientElement.element.properties = _.omit(clientElement.element.properties, key2Delete);
              clientElement.title = titleForElement(clientElement.element);
              if (elementType === 'vertex') {
                results1.push(window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []));
              } else {
                results1.push(window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []));
              }
            }
            return results1;
          } else {
            return alert("Graph update failed.  Nothing changed.  Maybe try again?");
          }
        });
      }
    }
    changedProps = {};
    ref1 = _.keys(newProps);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      key = ref1[l];
      if (oldProps[key] === void 0) {
        changedProps[key] = newProps[key];
      } else {
        if (newProps[key].toString() !== oldProps[key].toString()) {
          changedProps[key] = newProps[key];
        }
      }
    }
    if (!$.isEmptyObject(changedProps)) {
      if (elementType === 'vertex') {
        script = 'v=g.V(' + id + ').next();';
      } else {
        script = 'v=g.E("' + id + '").next();';
      }
      ref2 = _.keys(changedProps);
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        key = ref2[m];
        script = script + 'v.property("' + key + '","' + changedProps[key] + '");';
      }
      script = script + 'v ';
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, endTime, json, results;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
            } else {
              results = json.result.data;
            }
            if (elementType === 'vertex') {
              clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
            } else {
              clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
            }
            clientElement.element = results[0];
            clientElement.title = titleForElement(clientElement.element);
            delete clientElement.x;
            delete clientElement.y;
            if (elementType === 'vertex') {
              window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []);
            } else {
              window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []);
            }
            return getLabelSets();
          }
        };
        request = {
          requestId: uuid["new"](),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: {},
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, function(error, result) {
          if (result.success === true) {
            if (elementType === 'vertex') {
              clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
            } else {
              clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
            }
            clientElement.element = result.results[0];
            clientElement.title = titleForElement(clientElement.element);
            delete clientElement.x;
            delete clientElement.y;
            if (elementType === 'vertex') {
              window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []);
            } else {
              window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []);
            }
            return getLabelSets();
          } else {
            return alert("Graph update failed.  Nothing changed.  Maybe try again?");
          }
        });
      }
    }
  };

  getLabelSets = function() {
    var edge, edgeLabels, edgePropKeys, edges, j, l, len, len1, node, nodeLabels, nodePropKeys, nodes, sorted;
    nodes = _.values(window.visnetwork.nodesHandler.body.data.nodes._data);
    edges = _.values(window.visnetwork.edgesHandler.body.data.edges._data);
    nodeLabels = _.uniq((function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = nodes.length; j < len; j++) {
        node = nodes[j];
        results1.push(node.element.label);
      }
      return results1;
    })());
    edgeLabels = _.uniq((function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = edges.length; j < len; j++) {
        edge = edges[j];
        results1.push(edge.element.label);
      }
      return results1;
    })());
    nodePropKeys = [];
    edgePropKeys = [];
    for (j = 0, len = nodes.length; j < len; j++) {
      node = nodes[j];
      if (node.element.properties) {
        nodePropKeys = _.union(nodePropKeys, _.keys(node.element.properties));
      }
    }
    for (l = 0, len1 = edges.length; l < len1; l++) {
      edge = edges[l];
      if (edge.element.properties) {
        edgePropKeys = _.union(edgePropKeys, _.keys(edge.element.properties));
      }
    }
    sorted = _.sortBy(nodeLabels, function(it) {
      return it;
    });
    Session.set('vertexLabelSet', sorted);
    sorted = _.sortBy(edgeLabels, function(it) {
      return it;
    });
    Session.set('edgeLabelSet', sorted);
    sorted = _.sortBy(_.union(nodePropKeys, edgePropKeys), function(it) {
      return it;
    });
    return Session.set('vertexPropertyNames', sorted);
  };

  window.updateVertexLabelBootBox = function(ctxt) {
    return $('input.bootbox-input.bootbox-input-text.form-control')[0].value = ctxt.value;
  };

  addVertToGraph = function(nodeData, callback) {
    var fn, j, keyForLabel, label, labelSelectorHTML, labels, len, optionHTML;
    keyForLabel = Session.get('keyForNodeLabel');
    labels = Session.get('vertexLabelSet');
    labelSelectorHTML = '<select onchange="window.updateVertexLabelBootBox(this)">';
    optionHTML = '<option>Select a vertex label</option>';
    labelSelectorHTML = labelSelectorHTML + optionHTML;
    fn = function(label) {
      optionHTML = '<option>' + label + '</option>';
      return labelSelectorHTML = labelSelectorHTML + optionHTML;
    };
    for (j = 0, len = labels.length; j < len; j++) {
      label = labels[j];
      fn(label);
    }
    labelSelectorHTML = labelSelectorHTML + '</select>';
    label = "";
    return bootbox.prompt("<p>Enter the label for this new vertex or choose one of these " + labelSelectorHTML + "</p><p>Vertex labels are immutable (can't be changed), so choose wisely.</p>", function(result) {
      var request, script, startTime;
      label = result;
      if (label === null || label === "") {
        callback(null);
        return;
      }
      script = 'g.addV("' + label + '")';
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, endTime, json, results, v;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
              nodeData = [];
            } else {
              results = json.result.data;
              v = results[0];
              if ((Session.get('tinkerPopVersion')) === '3') {
                nodeData.id = String(v.id);
              } else {
                nodeData.id = String(v._id);
              }
              nodeData.label = labelForVertex(v, keyForLabel);
              nodeData.allowedToMoveX = true;
              nodeData.allowedToMoveY = true;
              nodeData.title = titleForElement(v);
              nodeData.element = v;
              nodeData.physics = false;
            }
            getLabelSets();
            return callback(nodeData);
          }
        };
        request = {
          requestId: uuid["new"](),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: {},
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, function(error, result) {
          var v;
          if (result.success === true) {
            v = result.results[0];
            if ((Session.get('tinkerPopVersion')) === '3') {
              nodeData.id = String(v.id);
            } else {
              nodeData.id = String(v._id);
            }
            nodeData.label = labelForVertex(v, keyForLabel);
            nodeData.allowedToMoveX = true;
            nodeData.allowedToMoveY = true;
            nodeData.title = titleForElement(v);
            nodeData.element = v;
            nodeData.physics = false;
            getLabelSets();
            return callback(nodeData);
          } else {
            return alert("Graph update failed.  Nothing changed");
          }
        });
      }
    });
  };

  cloneVertToGraph = function(id) {
    var j, key, len, node2Clone, ref, request, script, startTime, v2c, vertex2Clone;
    node2Clone = window.visnetwork.body.data.nodes._data[id];
    vertex2Clone = node2Clone.element;
    script = 'g.addV("' + vertex2Clone.label + '")';
    v2c = _.clone(vertex2Clone);
    delete v2c.type;
    delete v2c.label;
    delete v2c.id;
    ref = Object.keys(v2c.properties);
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      script = script + '.property("' + key + '","' + v2c.properties[key][0].value + '")';
    }
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json, newNode, oldLoc, results, v;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          results = json.result.data;
          v = results[0];
          newNode = {
            id: String(v.id),
            label: labelForVertex(v, Session.get('keyForNodeLabel')),
            allowedToMoveX: true,
            allowedToMoveY: true,
            title: titleForElement(v),
            element: v
          };
          window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
          oldLoc = (window.visnetwork.getPositions([node2Clone.id]))[node2Clone.id];
          window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
          return window.visnetwork.setSelection({
            nodes: [newNode.id],
            edges: []
          }, {
            unselectedAll: false,
            highlightEdges: false
          });
        }
      };
      request = {
        requestId: uuid["new"](),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: {},
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Vertex cloner', script, function(error, result) {
        var newNode, oldLoc, v;
        if (result.success === true) {
          v = result.results[0];
          newNode = {
            id: String(v.id),
            label: labelForVertex(v, Session.get('keyForNodeLabel')),
            allowedToMoveX: true,
            allowedToMoveY: true,
            title: titleForElement(v),
            element: v
          };
          window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
          oldLoc = (window.visnetwork.getPositions([node2Clone.id]))[node2Clone.id];
          window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
          return window.visnetwork.setSelection({
            nodes: [newNode.id],
            edges: []
          }, {
            unselectedAll: false,
            highlightEdges: false
          });
        } else {
          return alert("Graph update failed.  Nothing changed: " + script);
        }
      });
    }
  };

  invertSelections = function() {
    var allEdges, allNodes, edge, edges2Select, node, nodes2Select, selectedEdges, selectedNodes, selections;
    allNodes = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.nodes.get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        results1.push(node.id);
      }
      return results1;
    })();
    allEdges = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.edges.get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        edge = ref[j];
        results1.push(edge.id);
      }
      return results1;
    })();
    selections = window.visnetwork.getSelection();
    selectedNodes = selections.nodes;
    selectedEdges = selections.edges;
    nodes2Select = _.difference(allNodes, selectedNodes);
    edges2Select = _.difference(allEdges, selectedEdges);
    return window.visnetwork.setSelection({
      nodes: nodes2Select,
      edges: edges2Select
    });
  };

  selectAll = function() {
    var edge, edges2Select, node, nodes2Select;
    nodes2Select = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.nodes.get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        results1.push(node.id);
      }
      return results1;
    })();
    edges2Select = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.edges.get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        edge = ref[j];
        results1.push(edge.id);
      }
      return results1;
    })();
    return window.visnetwork.setSelection({
      nodes: nodes2Select,
      edges: edges2Select
    }, {
      unselectedAll: true,
      highlightEdges: false
    });
  };

  selectNone = function() {
    return window.visnetwork.unselectAll();
  };

  pinSelections = function() {
    var eds, elementIDs, j, len, nds, nodeID, ref, results1;
    elementIDs = window.visnetwork.getSelection();
    nds = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
    eds = window.visnetwork.edgesHandler.body.data.edges.getDataSet();
    ref = elementIDs.nodes;
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      results1.push(nds.update({
        id: nodeID,
        physics: false
      }));
    }
    return results1;
  };

  unpinSelections = function() {
    var eds, elementIDs, j, len, nds, nodeID, ref, results1;
    elementIDs = window.visnetwork.getSelection();
    nds = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
    eds = window.visnetwork.edgesHandler.body.data.edges.getDataSet();
    ref = elementIDs.nodes;
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      results1.push(nds.update({
        id: nodeID,
        physics: true
      }));
    }
    return results1;
  };

  inspectSelections = function() {
    var edgeID, element, elementIDs, elementType, j, l, len, len1, nodeID, ref, ref1, results1;
    elementIDs = window.visnetwork.getSelection();
    ref = elementIDs.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      elementType = 'vertex';
      element = window.visnetwork.nodesHandler.body.data.nodes.get(nodeID);
      window.popupPropertyEditor(element, elementType);
    }
    ref1 = elementIDs.edges;
    results1 = [];
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      edgeID = ref1[l];
      elementType = 'edge';
      element = window.visnetwork.edgesHandler.body.data.edges.get(edgeID);
      results1.push(window.popupPropertyEditor(element, elementType));
    }
    return results1;
  };

  shareGremlinCodeForIngestion = function() {
    var script, title, wnd;
    script = scriptForGeneralIngestionFindOrCreate();
    wnd = window.open("", "", "_blank");
    title = "<title>Gremlin code to use with JSON bindings to programmatically add elements</title>";
    return wnd.document.write(title + "<pre><code>" + script + "</code></pre>");
  };

  inputGremlinCodeForIngestion = function() {
    var bindings;
    bindings = JSON.parse(prompt('Paste bindings JSON here'));
    console.log(bindings);
    return addElementsFromBindingsJSON(bindings);
  };

  generateJSONBindingsForSelections = function() {
    var bindings, edge, edgeID, edgesJSON, elementIDs, j, l, len, len1, node, nodeID, ref, ref1, styles, title, vertsJSON, wnd;
    elementIDs = window.visnetwork.getSelection();
    vertsJSON = [];
    styles = {};
    ref = elementIDs.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      node = window.visnetwork.nodesHandler.body.data.nodes.get(nodeID);
      vertsJSON.push(node.element);
      styles[nodeID] = _.omit(node, ['element', 'id', 'x', 'y', 'label', 'physics', 'allowedToMoveX', 'allowedToMoveY', 'title']);
    }
    edgesJSON = [];
    ref1 = elementIDs.edges;
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      edgeID = ref1[l];
      edge = window.visnetwork.edgesHandler.body.data.edges.get(edgeID);
      edgesJSON.push(edge.element);
      styles[edgeID] = _.omit(edge, ['element', 'id', 'from', 'to', 'label', 'title']);
    }
    bindings = {
      "verts2FindOrCreate": [],
      "vertsJSON": vertsJSON,
      "edgesJSON": edgesJSON,
      "transactionContext": "ingesting a subgraph",
      "locations": window.visnetwork.getPositions(elementIDs.nodes),
      "styles": styles
    };

    /*
      link = document.createElement('a')
      link.download = 'bindings-for-tinkertools-selections.json'
      blob = new Blob([JSON.stringify(bindings, null, 2)], {type: 'text/plain'})
      link.href = window.URL.createObjectURL(blob)
      link.click()
     */
    wnd = window.open("", "", "_blank");
    title = "<title>JSON bindings for selected graph elements</title>";
    return wnd.document.write(title + "<pre><code>" + JSON.stringify(bindings, null, 2) + "</code></pre>");
  };

  spawnToQuikVis = function() {
    var allEdges, allNodes, positions;
    allNodes = window.visnetwork.getSelectedNodes();
    allEdges = window.visnetwork.getSelectedEdges();
    positions = window.visnetwork.getPositions(allNodes);
    return spawnTheseToQuikVis("selections", allNodes, allEdges, positions);
  };

  spawnTheseToQuikVis = function(subtitle, allNodes, allEdges, positions) {
    var script, specs, tinkertoolsServerURL, title, url, wnd;
    script = "vertIDs = " + JSON.stringify(allNodes) + "\n";
    script = script + "edgeIDs = " + JSON.stringify(allEdges) + "\n";
    script = script + "if (vertIDs != []) {vs = g.V(vertIDs).toList()}else{vs=[]}" + "\n";
    script = script + "if (edgeIDs != []) {es = g.E(edgeIDs).toList()}else{es=[]}" + "\n";
    script = script + "[vs,es]" + "\n";
    tinkertoolsServerURL = (Meteor.absoluteUrl()).slice(0, -1);
    if (tinkertoolsServerURL.slice(-5) === ':3000') {

    } else {
      tinkertoolsServerURL = tinkertoolsServerURL + ':3000';
    }
    url = tinkertoolsServerURL + "/quikvis?serverURL=" + Session.get('serverURL');
    url = url + '&width="auto"';
    url = url + '&height="1000px"';
    url = url + "&graphName=the default graph";
    url = url + "&scripts=";
    specs = JSON.stringify([
      {
        title: 'Show elements',
        script: script
      }
    ]);
    url = url + encodeURIComponent(specs);
    url = url + "&positions=" + JSON.stringify(positions);
    wnd = window.open("", "", "_blank");
    title = "<title>Spawned " + subtitle + " from Server: " + (Session.get('serverURL')) + "</title>";
    return wnd.document.write(title + "<div></div><h4>From Server: " + (Session.get('serverURL')) + "  Script used</h4><textarea rows='1' cols='150'>" + script + "</textarea></div><iframe width='100%' height='100%' src='" + url + "'>");
  };

  spawnAllToQuikVis = function() {
    var allEdges, allNodes, edge, node, positions;
    allNodes = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.nodes.getDataSet().get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        results1.push(node.id);
      }
      return results1;
    })();
    allEdges = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.edgesHandler.body.data.edges.getDataSet().get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        edge = ref[j];
        results1.push(edge.id);
      }
      return results1;
    })();
    positions = window.visnetwork.getPositions(allNodes);
    return spawnTheseToQuikVis("graph", allNodes, allEdges, positions);
  };

  inspectNone = function() {
    return $(".ui-dialog").detach();
  };

  hideSelections1 = function() {
    var edge, edges2Hide, elementIDs, j, l, len, len1, node, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.hidden1 = window.hidden1 ? window.hidden1 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    for (j = 0, len = nodes2Hide.length; j < len; j++) {
      node = nodes2Hide[j];
      node.physics = false;
    }
    for (l = 0, len1 = edges2Hide.length; l < len1; l++) {
      edge = edges2Hide[l];
      edge.physics = true;
    }
    window.hidden1.nodes = _.union(window.hidden1.nodes, nodes2Hide);
    window.hidden1.edges = _.union(window.hidden1.edges, edges2Hide);
    window.hidden1.positions = _.extend(window.hidden1.positions, window.visnetwork.getPositions(elementIDs.nodes));
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
    window.visnetwork.setSelection({
      nodes: [],
      edges: []
    });
    return $(".context-hideSelections1").text("" + window.hidden1.nodes.length + "v," + window.hidden1.edges.length + "e");
  };

  unhideSelections1 = function() {
    var each, j, len, node, oldLoc, ref;
    window.hidden1 = window.hidden1 ? window.hidden1 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    window.visnetwork.body.data.nodes.getDataSet().add(window.hidden1.nodes);
    window.visnetwork.body.data.edges.getDataSet().add(window.hidden1.edges);
    window.visnetwork.setSelection({
      nodes: (function() {
        var j, len, ref, results1;
        ref = window.hidden1.nodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })(),
      edges: (function() {
        var j, len, ref, results1;
        ref = window.hidden1.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })()
    });
    ref = window.hidden1.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = window.hidden1.positions[node.id];
      window.visnetwork.moveNode(node.id, oldLoc.x, oldLoc.y);
    }
    window.hidden1 = {
      nodes: [],
      edges: [],
      positions: {}
    };
    return $(".context-hideSelections1").text("Hide1");
  };

  window.hidden1 = {
    nodes: [],
    edges: [],
    positions: {}
  };

  spawnHidden1 = function() {
    var each, hiddenEdges, hiddenNodes;
    hiddenNodes = (function() {
      var j, len, ref, results1;
      ref = window.hidden1.nodes;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    hiddenEdges = (function() {
      var j, len, ref, results1;
      ref = window.hidden1.edges;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    return spawnTheseToQuikVis("contents of hidden buffer 1", hiddenNodes, hiddenEdges, window.hidden1.positions);
  };

  hideSelections2 = function() {
    var edge, edges2Hide, elementIDs, j, l, len, len1, node, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.hidden2 = window.hidden2 ? window.hidden2 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    for (j = 0, len = nodes2Hide.length; j < len; j++) {
      node = nodes2Hide[j];
      node.physics = false;
    }
    for (l = 0, len1 = edges2Hide.length; l < len1; l++) {
      edge = edges2Hide[l];
      edge.physics = true;
    }
    window.hidden2.nodes = _.union(window.hidden2.nodes, nodes2Hide);
    window.hidden2.edges = _.union(window.hidden2.edges, edges2Hide);
    window.hidden2.positions = _.extend(window.hidden2.positions, window.visnetwork.getPositions(elementIDs.nodes));
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
    window.visnetwork.setSelection({
      nodes: [],
      edges: []
    });
    return $(".context-hideSelections2").text("" + window.hidden2.nodes.length + "v," + window.hidden2.edges.length + "e");
  };

  unhideSelections2 = function() {
    var each, j, len, node, oldLoc, ref;
    window.hidden2 = window.hidden2 ? window.hidden2 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    window.visnetwork.body.data.nodes.getDataSet().add(window.hidden2.nodes);
    window.visnetwork.body.data.edges.getDataSet().add(window.hidden2.edges);
    window.visnetwork.setSelection({
      nodes: (function() {
        var j, len, ref, results1;
        ref = window.hidden2.nodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })(),
      edges: (function() {
        var j, len, ref, results1;
        ref = window.hidden2.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })()
    });
    ref = window.hidden2.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = window.hidden2.positions[node.id];
      window.visnetwork.moveNode(node.id, oldLoc.x, oldLoc.y);
    }
    window.hidden2 = {
      nodes: [],
      edges: [],
      positions: {}
    };
    return $(".context-hideSelections2").text("Hide2");
  };

  window.hidden2 = {
    nodes: [],
    edges: [],
    positions: {}
  };

  spawnHidden2 = function() {
    var each, hiddenEdges, hiddenNodes;
    hiddenNodes = (function() {
      var j, len, ref, results1;
      ref = window.hidden2.nodes;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    hiddenEdges = (function() {
      var j, len, ref, results1;
      ref = window.hidden2.edges;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    return spawnTheseToQuikVis("contents of hidden buffer 2", hiddenNodes, hiddenEdges, window.hidden2.positions);
  };

  hideSelections3 = function() {
    var edge, edges2Hide, elementIDs, j, l, len, len1, node, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.hidden3 = window.hidden3 ? window.hidden3 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    for (j = 0, len = nodes2Hide.length; j < len; j++) {
      node = nodes2Hide[j];
      node.physics = false;
    }
    for (l = 0, len1 = edges2Hide.length; l < len1; l++) {
      edge = edges2Hide[l];
      edge.physics = true;
    }
    window.hidden3.nodes = _.union(window.hidden3.nodes, nodes2Hide);
    window.hidden3.edges = _.union(window.hidden3.edges, edges2Hide);
    window.hidden3.positions = _.extend(window.hidden3.positions, window.visnetwork.getPositions(elementIDs.nodes));
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
    window.visnetwork.setSelection({
      nodes: [],
      edges: []
    });
    return $(".context-hideSelections3").text("" + window.hidden3.nodes.length + "v," + window.hidden3.edges.length + "e");
  };

  unhideSelections3 = function() {
    var each, j, len, node, oldLoc, ref;
    window.hidden3 = window.hidden3 ? window.hidden3 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    window.visnetwork.body.data.nodes.getDataSet().add(window.hidden3.nodes);
    window.visnetwork.body.data.edges.getDataSet().add(window.hidden3.edges);
    window.visnetwork.setSelection({
      nodes: (function() {
        var j, len, ref, results1;
        ref = window.hidden3.nodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })(),
      edges: (function() {
        var j, len, ref, results1;
        ref = window.hidden3.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })()
    });
    ref = window.hidden3.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = window.hidden3.positions[node.id];
      window.visnetwork.moveNode(node.id, oldLoc.x, oldLoc.y);
    }
    window.hidden3 = {
      nodes: [],
      edges: [],
      positions: {}
    };
    return $(".context-hideSelections3").text("Hide3");
  };

  window.hidden3 = {
    nodes: [],
    edges: [],
    positions: {}
  };

  spawnHidden3 = function() {
    var each, hiddenEdges, hiddenNodes;
    hiddenNodes = (function() {
      var j, len, ref, results1;
      ref = window.hidden3.nodes;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    hiddenEdges = (function() {
      var j, len, ref, results1;
      ref = window.hidden3.edges;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    return spawnTheseToQuikVis("contents of hidden buffer 3", hiddenNodes, hiddenEdges, window.hidden3.positions);
  };

  hideSelections4 = function() {
    var edge, edges2Hide, elementIDs, j, l, len, len1, node, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.hidden4 = window.hidden4 ? window.hidden4 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    for (j = 0, len = nodes2Hide.length; j < len; j++) {
      node = nodes2Hide[j];
      node.physics = false;
    }
    for (l = 0, len1 = edges2Hide.length; l < len1; l++) {
      edge = edges2Hide[l];
      edge.physics = true;
    }
    window.hidden4.nodes = _.union(window.hidden4.nodes, nodes2Hide);
    window.hidden4.edges = _.union(window.hidden4.edges, edges2Hide);
    window.hidden4.positions = _.extend(window.hidden4.positions, window.visnetwork.getPositions(elementIDs.nodes));
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
    window.visnetwork.setSelection({
      nodes: [],
      edges: []
    });
    return $(".context-hideSelections4").text("" + window.hidden4.nodes.length + "v," + window.hidden4.edges.length + "e");
  };

  unhideSelections4 = function() {
    var each, j, len, node, oldLoc, ref;
    window.hidden4 = window.hidden4 ? window.hidden4 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    window.visnetwork.body.data.nodes.getDataSet().add(window.hidden4.nodes);
    window.visnetwork.body.data.edges.getDataSet().add(window.hidden4.edges);
    window.visnetwork.setSelection({
      nodes: (function() {
        var j, len, ref, results1;
        ref = window.hidden4.nodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })(),
      edges: (function() {
        var j, len, ref, results1;
        ref = window.hidden4.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })()
    });
    ref = window.hidden4.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = window.hidden4.positions[node.id];
      window.visnetwork.moveNode(node.id, oldLoc.x, oldLoc.y);
    }
    window.hidden4 = {
      nodes: [],
      edges: [],
      positions: {}
    };
    return $(".context-hideSelections4").text("Hide4");
  };

  window.hidden4 = {
    nodes: [],
    edges: [],
    positions: {}
  };

  spawnHidden4 = function() {
    var each, hiddenEdges, hiddenNodes;
    hiddenNodes = (function() {
      var j, len, ref, results1;
      ref = window.hidden4.nodes;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    hiddenEdges = (function() {
      var j, len, ref, results1;
      ref = window.hidden4.edges;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    return spawnTheseToQuikVis("contents of hidden buffer 4", hiddenNodes, hiddenEdges, window.hidden4.positions);
  };

  allHiddenNodeIDs = function() {
    var each, j, len, ref, results1;
    ref = window.hidden1.nodes.concat(window.hidden2.nodes, window.hidden3.nodes, window.hidden4.nodes);
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      each = ref[j];
      results1.push(each.id);
    }
    return results1;
  };

  allHiddenEdgeIDs = function() {
    var each, j, len, ref, results1;
    ref = window.hidden1.edges.concat(window.hidden2.edges, window.hidden3.edges, window.hidden4.edges);
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      each = ref[j];
      results1.push(each.id);
    }
    return results1;
  };

  dropSelections = function() {
    var edges2Hide, elementIDs, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    return window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
  };

  growSelections = function() {
    var bindings, elementIDs, nl, request, script, startTime;
    elementIDs = window.visnetwork.getSelection();
    if (elementIDs.nodes.length > 0) {
      bindings = {
        vIDs: elementIDs.nodes
      };
      nl = "\n";
      script = "//answer all neighbors to these node IDs, vIDs is a binding" + nl + "inVs = vIDs.collect { g.V(it).in().toList() }" + nl + "inVs = inVs.flatten().unique()" + nl + "outVs = vIDs.collect { g.V(it).out().toList() }" + nl + "outVs = outVs.flatten().unique()" + nl + "inEs = vIDs.collect { g.V(it).inE().toList() }" + nl + "inEs = inEs.flatten().unique()" + nl + "outEs = vIDs.collect { g.V(it).outE().toList() }" + nl + "outEs = outEs.flatten().unique()" + nl + "[inVs,outVs,inEs,outEs]";
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var ahe, ahn, allE, allV, data, edges2Select, eds, endTime, inEs, inVs, json, nds, nodes2Select, outEs, outVs, results;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              return results = [];
            } else {
              results = json.result.data;
              nds = window.visnetwork.body.data.nodes.getDataSet();
              eds = window.visnetwork.body.data.edges.getDataSet();
              inVs = _.filter(results[0], function(e) {
                return nds.get(e.id) === null;
              });
              outVs = _.filter(results[1], function(e) {
                return nds.get(e.id) === null;
              });
              inEs = _.filter(results[2], function(e) {
                return eds.get(e.id) === null;
              });
              outEs = _.filter(results[3], function(e) {
                return eds.get(e.id) === null;
              });
              allV = _.uniq(_.union(inVs, outVs));
              ahn = allHiddenNodeIDs();
              allV = _.reject(allV, function(node) {
                return _.contains(ahn, node.id + "");
              });
              allE = _.uniq(_.union(inEs, outEs));
              ahe = allHiddenEdgeIDs();
              allE = _.reject(allE, function(edge) {
                return _.contains(ahe, edge.id);
              });
              nodes2Select = _.initial(elementIDs.nodes, 0);
              edges2Select = _.initial(elementIDs.edges, 0);
              if (allV.length > 100) {
                return selectNeighborsToAdd(nodes2Select, edges2Select, allV, allE);
              } else {
                return addInTheNeighbors(nodes2Select, edges2Select, allV, allE);
              }
            }
          }
        };
        request = {
          requestId: uuid["new"](),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: bindings,
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Get neighbors', script, bindings, function(error, result) {
          var ahe, ahn, allE, allV, edges2Select, eds, inEs, inVs, nds, nodes2Select, outEs, outVs, results;
          if (result.success === true) {
            results = result.results;
            console.log(results);
            nds = window.visnetwork.body.data.nodes.getDataSet();
            eds = window.visnetwork.body.data.edges.getDataSet();
            inVs = _.filter(results[0], function(e) {
              return nds.get(e.id) === null;
            });
            outVs = _.filter(results[1], function(e) {
              return nds.get(e.id) === null;
            });
            inEs = _.filter(results[2], function(e) {
              return eds.get(e.id) === null;
            });
            outEs = _.filter(results[3], function(e) {
              return eds.get(e.id) === null;
            });
            allV = _.uniq(_.union(inVs, outVs));
            ahn = allHiddenNodeIDs();
            allV = _.reject(allV, function(node) {
              return _.contains(ahn, node.id + "");
            });
            allE = _.uniq(_.union(inEs, outEs));
            ahe = allHiddenEdgeIDs();
            allE = _.reject(allE, function(edge) {
              return _.contains(ahe, edge.id);
            });
            nodes2Select = _.initial(elementIDs.nodes, 0);
            edges2Select = _.initial(elementIDs.edges, 0);
            if (allV.length + allE.length > 20) {
              return selectNeighborsToAdd(nodes2Select, edges2Select, allV, allE);
            } else {
              return addInTheNeighbors(nodes2Select, edges2Select, allV, allE);
            }
          } else {
            return alert("Graph update failed.  Nothing changed.  Maybe try again?");
          }
        });
      }
    }
  };

  expandSelections = function() {
    var edgeID, edges2Select, elementIDs, j, l, len, len1, len2, len3, m, n, newEdge, newEdges, newNode, newNodes, nodeID, nodes2Select, ref, ref1;
    elementIDs = window.visnetwork.getSelection();
    nodes2Select = _.initial(elementIDs.nodes, 0);
    edges2Select = _.initial(elementIDs.edges, 0);
    ref = elementIDs.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      newEdges = window.visnetwork.getConnectedEdges(nodeID);
      for (l = 0, len1 = newEdges.length; l < len1; l++) {
        newEdge = newEdges[l];
        edges2Select.push(newEdge);
      }
    }
    ref1 = elementIDs.edges;
    for (m = 0, len2 = ref1.length; m < len2; m++) {
      edgeID = ref1[m];
      newNodes = window.visnetwork.getConnectedNodes(edgeID);
      for (n = 0, len3 = newNodes.length; n < len3; n++) {
        newNode = newNodes[n];
        nodes2Select.push(newNode);
      }
    }
    return window.visnetwork.setSelection({
      nodes: _.uniq(nodes2Select),
      edges: _.uniq(edges2Select)
    });
  };

  expandSelections5 = function() {
    expandSelections();
    expandSelections();
    expandSelections();
    expandSelections();
    return expandSelections();
  };

  deleteSelections = function() {
    var bindings, elementIDs, request, script, startTime;
    elementIDs = window.visnetwork.getSelection();
    bindings = {
      "vertIDs": elementIDs.nodes,
      "edgeIDs": elementIDs.edges
    };
    script = "//given arrays of vert ids and edge ids, remove their elements in the graph" + "\n";
    if (elementIDs.nodes.length > 0) {
      script = script + "g.V(vertIDs).drop().iterate()" + "\n";
    }
    if (elementIDs.edges.length > 0) {
      script = script + "g.E(edgeIDs).drop().iterate()" + "\n";
    }
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
          return window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
        }
      };
      request = {
        requestId: uuid["new"](),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('usingWebServices'), 'Deleting a collection of verts and edges by id', script, bindings, function(error, result) {
        if (result.success === true) {
          window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
          return window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
        } else {
          return alert("Selection deletion failed.  Nothing changed; " + script);
        }
      });
    }
  };

  cloneSelections = function() {
    var elementIDs;
    elementIDs = window.visnetwork.getSelection();
    return cloneElements(elementIDs);
  };

  addElementsFromBindingsJSON = function(bindings) {
    var request, script, startTime;
    alert("Remember this function is not using gg()");
    script = 'if (bindings[\'vertsJSON\'] == null) {vertsJSON = []} else {vertsJSON = bindings[\'vertsJSON\']}\nif (bindings[\'edgesJSON\'] == null) {edgesJSON = []} else {edgesJSON = bindings[\'edgesJSON\']}\nif (bindings[\'verts2FindOrCreate\'] == null) {verts2FindOrCreate = []} else {verts2FindOrCreate = bindings[\'verts2FindOrCreate\']}\nif (bindings[\'transactionContext\'] == null) {transactionContext = \'unlabeled transaction context\'} else {transactionContext = bindings[\'transactionContext\']}\n\nvMap = [:]\nvMapFull = [:]\neMapFull = [:]\nverts2FindOrCreate.collect { json ->\n    trav = g.V().hasLabel(json.label)\n    json.properties.each { key, val ->\n        trav = trav.has(key, val[0].value)\n        }\n    results = trav.toList()\n   if (results.size == 0) {oldV = null} else {oldV = results[0]}\n    if (oldV == null){\n        //create it\n        newV = g.addV(json.label).next()\n        json.properties.each { key, val ->\n            g.V(newV.id()).property(key, val[0].value).next()\n            }\n    } else {\n        //reference it\n        newV = oldV\n    }\n    vMap[json.id] = newV.id()\n\n}\n\n\nvertsJSON.collect { json ->\n    newV = g.addV(json.label).next()\n    vMap[json.id] = newV.id()\n    vMapFull[json.id] = newV\n    json.properties.each { key, val ->\n        g.V(newV.id()).property(key, val[0].value).next()\n}}\nedgesJSON.collect { json ->\n    fromID = vMap[json.outV] ? vMap[json.outV] : json.outV\n    toID = vMap[json.inV] ? vMap[json.inV] : json.inV\n    newEdge=g.V(fromID).addE(json.label).to(g.V(toID)).next()\n    eMapFull[json.id] = newEdge\n    json.properties.collect { key, val ->\n        g.E(newEdge.id()).property(key, val.value).next()\n}}\n//answer the maps of old element ids to new elements\n[vMapFull, eMapFull]';
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, eMap, edgeIDsToSelect, endTime, json, loc, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldVID, results, styleForEdge, styleForNode, vMap;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            return results = [];
          } else {
            results = json.result.data;
            vMap = results[0];
            eMap = results[1];
            nodeIDsToSelect = [];
            edgeIDsToSelect = [];
            for (oldVID in vMap) {
              newV = vMap[oldVID];
              newNode = {
                physics: false,
                id: String(newV.id),
                label: labelForVertex(newV, Session.get('keyForNodeLabel')),
                allowedToMoveX: true,
                allowedToMoveY: true,
                title: titleForElement(newV),
                element: newV
              };
              window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
              if (bindings['locations'] && bindings.locations[oldVID]) {
                loc = bindings.locations[oldVID.toString()];
                window.visnetwork.moveNode(newNode.id, loc.x, loc.y);
              } else {
                window.visnetwork.moveNode(newNode.id, 0, 0);
              }
              if (bindings['styles'] && bindings.styles[oldVID.toString()]) {
                styleForNode = bindings.styles[oldVID.toString()];
                newNode = _.extend(newNode, styleForNode);
                window.visnetwork.nodesHandler.body.data.nodes.getDataSet().update(newNode);
                window.visnetwork.moveNode(newNode.id, loc.x, loc.y);
              }
              nodeIDsToSelect.push(newNode.id);
            }
            for (oldEID in eMap) {
              newE = eMap[oldEID];
              newEdge = {
                id: String(newE.id),
                label: newE.label,
                from: newE.outV,
                to: newE.inV,
                title: titleForElement(newE),
                element: newE
              };
              if (bindings['styles'] && bindings.styles[oldEID.toString()]) {
                styleForEdge = bindings.styles[oldEID.toString()];
                newEdge = _.extend(newEdge, styleForEdge);
              }
              window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
              edgeIDsToSelect.push(newEdge.id);
            }
            return window.visnetwork.setSelection({
              nodes: nodeIDsToSelect,
              edges: edgeIDsToSelect
            }, {
              unselectedAll: true,
              highlightEdges: false
            });
          }
        }
      };
      request = {
        requestId: uuid["new"](),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: {
            bindings: bindings
          },
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Subgraph ingestor from bindings JSON', script, {
        bindings: bindings
      }, function(error, result) {
        var eMap, edgeIDsToSelect, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldLoc, oldVID, vMap;
        if (result.success === true) {
          vMap = result.results[0];
          eMap = result.results[1];
          nodeIDsToSelect = [];
          edgeIDsToSelect = [];
          for (oldVID in vMap) {
            newV = vMap[oldVID];
            newNode = {
              id: String(newV.id),
              label: labelForVertex(newV, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElement(newV),
              element: newV
            };
            window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
            oldLoc = (window.visnetwork.getPositions([oldVID]))[oldVID];
            window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
            nodeIDsToSelect.push(newNode.id);
          }
          for (oldEID in eMap) {
            newE = eMap[oldEID];
            newEdge = {
              id: String(newE.id),
              label: newE.label,
              from: newE.outV,
              to: newE.inV,
              title: titleForElement(newE),
              element: newE
            };
            window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
            edgeIDsToSelect.push(newEdge.id);
          }
          return window.visnetwork.setSelection({
            nodes: nodeIDsToSelect,
            edges: edgeIDsToSelect
          }, {
            unselectedAll: true,
            highlightEdges: false
          });
        } else {
          return alert("Selection cloning failed.  Nothing changed; " + script);
        }
      });
    }
  };

  cloneElements = function(elementIDs) {
    var bindings, request, script, startTime;
    bindings = {
      "vertIDs": elementIDs.nodes,
      "edgeIDs": elementIDs.edges
    };
    script = "//given arrays of vert ids and edge ids, clone the subgraph defined into the graph" + "\n";
    script = script + "//clone vertices first" + "\n";
    script = script + "vMap = [:]" + "\n";
    script = script + "vMapFull = [:]" + "\n";
    script = script + "vertIDs.each { id ->" + "\n";
    script = script + "   oldVert = g.V(id).next()" + "\n";
    script = script + "   newVert = g.addV(oldVert.label()).next()" + "\n";
    script = script + "   vMap[oldVert.id()] = newVert.id()" + "\n";
    script = script + "   vMapFull[oldVert.id()] = newVert" + "\n";
    script = script + "   oldVert.properties().toList().collect {prop ->" + "\n";
    script = script + "       g.V(newVert.id()).property(prop.label(), prop.value()).next()" + "\n";
    script = script + "}}" + "\n";
    script = script + "//clone edges" + "\n";
    script = script + "eMapFull = [:]" + "\n";
    script = script + "edgeIDs.each { id ->" + "\n";
    script = script + "   oldEdge = g.E(id).next()" + "\n";
    script = script + "   fromID = vMap[oldEdge.outVertex().id()] ? vMap[oldEdge.outVertex().id()] : oldEdge.outVertex().id()" + "\n";
    script = script + "   toID = vMap[oldEdge.inVertex().id()] ? vMap[oldEdge.inVertex().id()] : oldEdge.inVertex().id()" + "\n";
    script = script + "   newEdge=g.V(fromID).addE(oldEdge.label()).to(g.V(toID)).next()" + "\n";
    script = script + "   eMapFull[oldEdge.id()] = newEdge" + "\n";
    script = script + "   oldEdge.properties().toList().collect { prop ->" + "\n";
    script = script + "       g.E(newEdge.id()).property(prop.key(), prop.value()).next()" + "\n";
    script = script + "}}" + "\n";
    script = script + "//answer the maps" + "\n";
    script = script + "[vMapFull,eMapFull]" + "\n";
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, eMap, edgeIDsToSelect, endTime, json, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldLoc, oldVID, results, vMap;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            return results = [];
          } else {
            results = json.result.data;
            vMap = results[0];
            eMap = results[1];
            nodeIDsToSelect = [];
            edgeIDsToSelect = [];
            for (oldVID in vMap) {
              newV = vMap[oldVID];
              newNode = {
                id: String(newV.id),
                label: labelForVertex(newV, Session.get('keyForNodeLabel')),
                allowedToMoveX: true,
                allowedToMoveY: true,
                title: titleForElement(newV),
                element: newV
              };
              window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
              oldLoc = (window.visnetwork.getPositions([oldVID]))[oldVID];
              window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
              nodeIDsToSelect.push(newNode.id);
            }
            for (oldEID in eMap) {
              newE = eMap[oldEID];
              newEdge = {
                id: String(newE.id),
                label: newE.label,
                from: newE.outV,
                to: newE.inV,
                title: titleForElement(newE),
                element: newE
              };
              window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
              edgeIDsToSelect.push(newEdge.id);
            }
            return window.visnetwork.setSelection({
              nodes: nodeIDsToSelect,
              edges: edgeIDsToSelect
            }, {
              unselectedAll: true,
              highlightEdges: false
            });
          }
        }
      };
      request = {
        requestId: uuid["new"](),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Subgraph cloner', script, bindings, function(error, result) {
        var eMap, edgeIDsToSelect, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldLoc, oldVID, vMap;
        if (result.success === true) {
          vMap = result.results[0];
          eMap = result.results[1];
          nodeIDsToSelect = [];
          edgeIDsToSelect = [];
          for (oldVID in vMap) {
            newV = vMap[oldVID];
            newNode = {
              id: String(newV.id),
              label: labelForVertex(newV, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElement(newV),
              element: newV
            };
            window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
            oldLoc = (window.visnetwork.getPositions([oldVID]))[oldVID];
            window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
            nodeIDsToSelect.push(newNode.id);
          }
          for (oldEID in eMap) {
            newE = eMap[oldEID];
            newEdge = {
              id: String(newE.id),
              label: newE.label,
              from: newE.outV,
              to: newE.inV,
              title: titleForElement(newE),
              element: newE
            };
            window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
            edgeIDsToSelect.push(newEdge.id);
          }
          return window.visnetwork.setSelection({
            nodes: nodeIDsToSelect,
            edges: edgeIDsToSelect
          }, {
            unselectedAll: true,
            highlightEdges: false
          });
        } else {
          return alert("Selection cloning failed.  Nothing changed; " + script);
        }
      });
    }
  };

  addEdgeToGraph = function(edgeData, callback) {
    var fn, j, label, labelSelectorHTML, labels, len, optionHTML;
    labels = Session.get('edgeLabelSet');
    labelSelectorHTML = '<select onchange="window.updateVertexLabelBootBox(this)" >';
    optionHTML = '<option>Select an edge label</option>';
    labelSelectorHTML = labelSelectorHTML + optionHTML;
    fn = function(label) {
      optionHTML = '<option>' + label + '</option>';
      return labelSelectorHTML = labelSelectorHTML + optionHTML;
    };
    for (j = 0, len = labels.length; j < len; j++) {
      label = labels[j];
      fn(label);
    }
    labelSelectorHTML = labelSelectorHTML + '</select>';
    bootbox.prompt("<p>Enter the label for this new edge or choose one of these " + labelSelectorHTML + "</p><p>Edge labels are immutable (can't be changed), so choose wisely.</p>", function(result) {
      var request, script, startTime;
      label = result;
      if (label === null || label === "") {
        callback(null);
        return;
      }
      script = 'fromV = g.V("' + edgeData.from + '");';
      script = script + 'toV = g.V("' + edgeData.to + '");';
      script = script + 'e = fromV.addE("' + label + '").to(toV)';
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, e, endTime, json, results;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
              edgeData = [];
            } else {
              results = json.result.data;
              e = results[0];
              edgeData.id = String(e.id);
              edgeData.from = String(e.outV);
              edgeData.to = String(e.inV);
              edgeData.label = e.label;
              edgeData.title = titleForElement(e);
              edgeData.element = e;
            }
            getLabelSets();
            return callback(edgeData);
          }
        };
        request = {
          requestId: uuid["new"](),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: {},
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, function(error, result) {
          var e;
          if (result.success === true) {
            e = result.results[0];
            edgeData.id = String(e.id);
            edgeData.from = String(e.outV);
            edgeData.to = String(e.inV);
            edgeData.label = e.label;
            edgeData.title = titleForElement(e);
            edgeData.element = e;
            getLabelSets();
            return callback(edgeData);
          } else {
            return alert("Graph update failed.  Nothing changed");
          }
        });
      }
    });
    return getLabelSets();
  };

  deleteSelected = function(selections, callback) {
    var bindings, edgeIDs, nodeIDs, request, script, startTime;
    nodeIDs = selections.nodes;
    edgeIDs = selections.edges;
    script = 'nodeIDs.each {nodeID -> g.V(nodeID).drop()}; edgeIDs.each {edgeID -> g.V(edgeID).drop()}; ';
    bindings = {
      nodeIDs: nodeIDs,
      edgeIDs: edgeIDs
    };
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          return callback(selections);
        }
      };
      request = {
        requestId: uuid["new"](),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: {
            nodeIDs: nodeIDs,
            edgeIDs: edgeIDs
          },
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, bindings, function(error, result) {
        if (result.success === true) {
          return callback(selections);
        } else {
          return alert("Graph update failed.  Nothing changed");
        }
      });
    }
  };

  userPropertiesForElement = function(element) {
    var j, key, len, props, ref;
    props = {};
    if (element["properties"] !== void 0) {
      ref = _.keys(element.properties);
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        if (element.type === "vertex") {
          props[key] = element.properties[key][0].value;
        } else {
          props[key] = element.properties[key];
        }
      }
    }
    return props;
  };

  labelForVertex = function(vertex, keyForLabel) {
    var key, labelPrefix, nl, suffix;
    if (keyForLabel === void 0) {
      key = "null";
    } else {
      key = keyForLabel;
    }
    if (Session.get('useLabelPrefix')) {
      labelPrefix = vertex.label;
    } else {
      labelPrefix = "";
    }
    suffix = "";
    if (vertex[key] === void 0) {
      if (vertex.properties[key] !== void 0) {
        suffix = key + ": " + vertex.properties[key][0].value;
      } else {
        suffix = "";
        nl = "";
      }
    } else {
      suffix = key + ": " + vertex[key];
    }
    if (suffix !== "") {
      nl = '\n';
    } else {
      nl = "";
    }
    return labelPrefix + nl + suffix;
  };

  allKeysInVerts = function(verts) {
    var allKeys, j, k, l, len, len1, ref, v;
    allKeys = ['id', 'label'];
    for (j = 0, len = verts.length; j < len; j++) {
      v = verts[j];
      ref = Object.keys(v.properties);
      for (l = 0, len1 = ref.length; l < len1; l++) {
        k = ref[l];
        allKeys.push(k);
      }
    }
    return _.uniq(allKeys);
  };

  window.updateEdgeColors = function() {
    var conf, edge, j, len, ref, results1;
    conf = window.visnetwork.configurator.moduleOptions;
    ref = _.values(window.visnetwork.edgesHandler.body.data.edges._data);
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      edge = ref[j];
      console.log(edge);
      if (edge.color === void 0) {
        edge.color = {};
      }
      edge.color = conf.edges.color.color;
      edge.color.highlight = conf.edges.color.highlight;
      edge.color.hover = conf.edges.color.hover;
      edge.color.opacity = conf.edges.color.opacity;
      edge.color.inherit = conf.edges.color.inherit;
      results1.push(window.visnetwork.edgesHandler.body.data.edges.update([edge], []));
    }
    return results1;
  };

  window.renderGraph = function() {
    Session.set('graphRenderingStatus', 'Rendering...');
    return Session.set('renderStartTime', moment().toDate());
  };

  window.setUpVis = function() {
    var canvas, config, container, ctx, data, defaultOptions, drag, drawingSurfaceImageData, getStartToEnd, options, rect, restoreDrawingSurface, saveDrawingSurface, selectEdges, selectNodes, selectNodesFromHighlight, updateNodelabels, visOptions;
    this.find('.results-vis')._uihooks;
    container = document.getElementById('mynetwork');
    config = document.getElementById('vis-config');
    $(config).hide();
    visOptions = Session.get('visOptions');
    defaultOptions = {
      interaction: {
        hover: true,
        navigationButtons: true,
        multiselect: true,
        dragView: true,
        selectConnectedEdges: false
      },
      manipulation: {
        addNode: function(nodeData, callback) {
          return addVertToGraph(nodeData, callback);
        },
        addEdge: function(edgeData, callback) {
          return addEdgeToGraph(edgeData, callback);
        },
        deleteNode: function(selections, callback) {
          return deleteSelected(selections, callback);
        },
        deleteEdge: function(selections, callback) {
          return deleteSelected(selections, callback);
        },
        editNode: function(node, callback) {
          window.popupPropertyEditor(window.visnetwork.nodesHandler.body.data.nodes.get(node.id), "vertex");
          return callback();
        },
        editEdge: false
      },
      configure: {
        enabled: true,
        container: config,
        showButton: true
      },
      physics: true,
      nodes: {
        shape: "box",
        labelHighlightBold: true,
        font: {
          face: 'arial'
        },
        hidden: false,
        borderWidth: 1,
        color: {
          hover: {
            border: '#ffff00',
            background: '#0066cc'
          },
          highlight: {
            border: '#ff0000',
            background: '#ffff00'
          }
        }
      },
      edges: {
        hidden: false,
        arrows: {
          to: {
            enabled: true,
            scaleFactor: 0.5
          }
        },
        color: {
          highlight: '#ff0000',
          hover: '#0066cc'
        }
      }
    };
    if (visOptions === void 0) {
      options = defaultOptions;
    } else {
      options = visOptions;
    }
    data = [];
    console.log("installing window.visnetwork");
    window.visnetwork = new vis.Network(container, data, options);
    window.visnetwork.on('afterDrawing', function(params) {
      var d, graph, renderStopTime;
      if ((Session.get("firstRender")) === 1) {
        renderStopTime = moment();
        d = moment.duration(Math.round((renderStopTime - moment(Session.get('renderStartTime'))) * 1000) / 1000);
        Session.set('elapsedRenderTime', durationToString(d));
        graph = Session.get('graphToShow');
        if (graph.nodes.length > 0) {
          Session.set('graphRenderingStatus', 'Finished ' + graph.nodes.length + 'V, ' + graph.edges.length + 'E');
        }
      }
      return Session.set("firstRender", (Session.get("firstRender")) + 1);
    });
    window.visnetwork.on('doubleClick', function(params) {
      var element, elementType;
      if (params.nodes.length !== 0) {
        elementType = 'vertex';
        element = window.visnetwork.nodesHandler.body.data.nodes.get(params.nodes[0]);
      } else {
        if (params.edges.length === 1) {
          elementType = 'edge';
          element = window.visnetwork.edgesHandler.body.data.edges.get(params.edges[0]);
        } else {
          return;
        }
      }
      return window.popupPropertyEditor(element, elementType);
    });
    $('.context-cloneSelections').click(function() {
      var params;
      params = window.visnetwork.getSelection();
      return cloneSelections(params.nodes, params.edges);
    });
    $('.context-deleteSelections').click(function() {
      var params;
      params = window.visnetwork.getSelection();
      return bootbox.confirm({
        message: "Do you really want to delete " + params.nodes.length + " vertices and " + params.edges.length + " edges?  (no undo)",
        buttons: {
          confirm: {
            label: 'Yes, delete them',
            className: 'btn-success'
          },
          cancel: {
            label: "No, don't delete anything",
            className: 'btn-danger'
          }
        },
        callback: function(result) {
          if (result) {
            return deleteSelections(params.nodes, params.edges);
          }
        }
      });
    });
    $('.context-expandSelections').click(function() {
      return expandSelections();
    });
    $('.context-expandSelections5').click(function() {
      return expandSelections5();
    });
    $('.context-dropSelections').click(function() {
      return dropSelections();
    });
    $('.context-growSelections').click(function() {
      return growSelections();
    });
    $('.context-selectAll').click(function() {
      return selectAll();
    });
    $('.context-selectNone').click(function() {
      return selectNone();
    });
    $('.context-invertSelections').click(function() {
      return invertSelections();
    });
    $('.context-hideSelections1').click(function() {
      return hideSelections1();
    });
    $('.context-unhideSelections1').click(function() {
      return unhideSelections1();
    });
    $('.context-spawnHidden1').click(function() {
      return spawnHidden1();
    });
    $('.context-hideSelections2').click(function() {
      return hideSelections2();
    });
    $('.context-unhideSelections2').click(function() {
      return unhideSelections2();
    });
    $('.context-spawnHidden2').click(function() {
      return spawnHidden2();
    });
    $('.context-hideSelections3').click(function() {
      return hideSelections3();
    });
    $('.context-unhideSelections3').click(function() {
      return unhideSelections3();
    });
    $('.context-spawnHidden3').click(function() {
      return spawnHidden3();
    });
    $('.context-hideSelections4').click(function() {
      return hideSelections4();
    });
    $('.context-unhideSelections4').click(function() {
      return unhideSelections4();
    });
    $('.context-spawnHidden4').click(function() {
      return spawnHidden4();
    });
    $('.context-inspectSelections').click(function() {
      return inspectSelections();
    });
    $('.context-inspectNone').click(function() {
      return inspectNone();
    });
    $('.context-pinSelections').click(function() {
      return pinSelections();
    });
    $('.context-unpinSelections').click(function() {
      return unpinSelections();
    });
    $('.context-generateJSONBindingsForSelections').click(function() {
      return generateJSONBindingsForSelections();
    });
    $('.context-shareGremlinCodeForIngestion').click(function() {
      return shareGremlinCodeForIngestion();
    });
    $('.context-inputGremlinCodeForIngestion').click(function() {
      return inputGremlinCodeForIngestion();
    });
    $('.context-spawnToQuikVis').click(function() {
      return spawnToQuikVis();
    });
    $('.context-spawnAllToQuikVis').click(function() {
      return spawnAllToQuikVis();
    });
    window.popupPropertyEditor = function(element, elementType) {
      var div, html, id, title;
      id = element.element.id;
      html = popupDialogForElement(element, elementType);
      title = elementType + ': ' + id;
      div = document.createElement('div');
      div["class"] = 'doubleClick-dialog';
      div.innerHTML = html;
      $(".vis-network").append(div);
      $(div).dialog({
        title: title,
        resizable: true,
        width: 400,
        height: "auto",
        beforeClose: function(event, ui) {
          return $(".propTableForElementID" + id).remove();
        }
      });
      $('.element-deleteProperty' + id).click(function() {
        $(this.parentNode.parentNode.parentNode.parentNode.parentNode).next().show();
        return this.parentNode.parentNode.parentNode.remove();
      });
      $('.element-copyProperty' + id).click(function() {
        var key, value;
        key = this.parentNode.parentNode.parentNode.children[0].innerText.slice(0, -1);
        value = this.parentNode.parentNode.parentNode.children[1].children[0].value;
        Session.set("propCopyBuffer", {
          key: key,
          value: value
        });
        return console.log("copied ", key, value);
      });
      $('.element-pasteProperty' + id).click(function() {
        var copyPropButton, deletePropButton, key, prop, tr, value;
        prop = Session.get("propCopyBuffer");
        if (prop) {
          key = prop.key;
          value = prop.value;
          $(".propTableForElementID" + id).next().show();
          deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
          copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
          tr = '<tr><td>' + key + ':  </td><td><input type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'button.commitButtonForElementID' + id + '\').show()"></td><th style="width:50" id="' + id + '" value="' + elementType + '" name="' + key + '">' + deletePropButton + copyPropButton + '</th></tr>';
          $(".propTableForElementID" + id).append(tr);
          return $('.element-deleteProperty' + id).click(function() {
            $(".propTableForElementID" + id).next().show();
            return this.parentNode.parentNode.parentNode.remove();
          });
        } else {
          return alert("Nothing to paste, try copying a property first");
        }
      });
      $('.element-log' + id).click(function() {
        var edge, node;
        node = window.visnetwork.nodesHandler.body.data.nodes.get(id);
        if (node) {
          return console.log(node);
        } else {
          edge = window.visnetwork.edgesHandler.body.data.edges.get(id);
          return console.log(edge);
        }
      });
      $('.clone-vertex' + id).click(function() {
        return cloneVertToGraph(id);
      });
      $('.clone-edge' + id).click(function() {
        return cloneElements({
          "nodes": [],
          "edges": [id]
        });
      });
      return $('.element-addProperty' + id).click(function() {
        return bootbox.dialog({
          title: "Enter a name for the new property",
          message: '<div class="row">  ' + '<div class="col-md-12"> ' + '<form class="form-horizontal"> ' + '<div class="form-group"> ' + '<label class="col-md-4 control-label" for="name">Key</label> ' + '<div class="col-md-4"> ' + '<input id="key' + id + '" name="key" type="text" placeholder="aPropertyName" class="form-control input-md"> ' + '</div> ' + '<label class="col-md-4 control-label" for="name">Value</label> ' + '<div class="col-md-4"> ' + '<input id="value' + id + '" name="value" type="text" placeholder="someValue" class="form-control input-md"> ' + '</div> ' + '</form> </div>  </div>',
          buttons: {
            confirm: {
              label: "Save",
              className: "btn-success",
              callback: function() {
                var copyPropButton, deletePropButton, key, tr, value;
                key = $('#key' + id + '').val();
                value = $('#value' + id + '').val();
                if (key === "id" | key === "label" | key === "type") {
                  return window.alert('Reserved property name disallowed: ' + key);
                } else {
                  $(".propTableForElementID" + id).next().show();
                  deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
                  copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
                  tr = '<tr><td>' + key + ':  </td><td><input type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'button.commitButtonForElementID' + id + '\').show()"></td><th style="width:50" id="' + id + '" value="' + elementType + '" name="' + key + '">' + deletePropButton + copyPropButton + '</th></tr>';
                  $(".propTableForElementID" + id).append(tr);
                  return $('.element-deleteProperty' + id).click(function() {
                    $(".propTableForElementID" + id).next().show();
                    return this.parentNode.parentNode.parentNode.remove();
                  });
                }
              }
            }
          }
        });
      });
    };
    $(".results-graph-fit").click(function() {
      return window.visnetwork.fit();
    });
    rect = {};
    drag = false;
    canvas = window.visnetwork.canvas.frame.canvas;
    ctx = canvas.getContext('2d');
    drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    saveDrawingSurface = function() {
      drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    };
    restoreDrawingSurface = function() {
      ctx.putImageData(drawingSurfaceImageData, 0, 0);
    };
    selectNodesFromHighlight = function() {
      var allNodes, curNode, i, nodePosition, nodeXY, nodesIdInDrawing, xRange, yRange;
      nodesIdInDrawing = Session.get('selectedNodes');
      xRange = getStartToEnd(rect.startX, rect.w);
      yRange = getStartToEnd(rect.startY, rect.h);
      allNodes = window.visnetwork.nodesHandler.body.data.nodes.get();
      i = 0;
      while (i < allNodes.length) {
        curNode = allNodes[i];
        nodePosition = window.visnetwork.getPositions([curNode.id]);
        nodeXY = window.visnetwork.canvasToDOM({
          x: nodePosition[curNode.id].x,
          y: nodePosition[curNode.id].y
        });
        if (xRange.start <= nodeXY.x && nodeXY.x <= xRange.end && yRange.start <= nodeXY.y && nodeXY.y <= yRange.end) {
          nodesIdInDrawing.push(curNode.id);
        }
        i++;
      }
      window.visnetwork.selectNodes(nodesIdInDrawing);
    };
    getStartToEnd = function(start, theLen) {
      var ret;
      if (theLen > 0) {
        ret = {
          start: start,
          end: start + theLen
        };
      } else {
        ret = {
          start: start + theLen,
          end: start
        };
      }
      return ret;
    };
    container = $("#mynetwork");
    container.on('mousemove', function(e) {
      if (drag) {
        restoreDrawingSurface();
        rect.w = e.pageX - this.offsetLeft - rect.startX;
        rect.h = e.pageY - this.offsetTop - rect.startY;
        ctx.setLineDash([5]);
        ctx.strokeStyle = 'rgb(0, 102, 0)';
        ctx.strokeRect(rect.startX, rect.startY, rect.w, rect.h);
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      }
    });
    container.on('mousedown', function(e) {
      var currentSelections, that;
      Session.set('selectedNodes', []);
      if (e.button === 2) {
        if (e.shiftKey) {
          currentSelections = window.visnetwork.getSelectedNodes();
          Session.set('selectedNodes', currentSelections);
        }
        saveDrawingSurface();
        that = this;
        rect.startX = e.pageX - this.offsetLeft;
        rect.startY = e.pageY - this.offsetTop;
        drag = true;
        container[0].style.cursor = 'crosshair';
      }
    });
    container.on('mouseup', function(e) {
      if (e.button === 2) {
        restoreDrawingSurface();
        drag = false;
        container[0].style.cursor = 'default';
        selectNodesFromHighlight();
      }
    });
    document.body.oncontextmenu = function() {
      return false;
    };
    $(".vis-options-node-hideShow").prop('checked', true);
    $(".vis-options-node-hideShow").change(function() {
      var newState, oldState;
      oldState = $(".vis-options-node-hideShow").prop('checked');
      newState = !oldState;
      return window.visnetwork.setOptions({
        nodes: {
          hidden: newState
        }
      });
    });
    $(".vis-options-edge-hideShow").prop('checked', true);
    $(".vis-options-edge-hideShow").change(function() {
      var newState, oldState;
      oldState = $(".vis-options-edge-hideShow").prop('checked');
      newState = !oldState;
      return window.visnetwork.setOptions({
        edges: {
          hidden: newState
        }
      });
    });
    $(".vis-options-physics-toggle").prop('checked', true);
    $(".vis-options-physics-toggle").change(function() {
      var state;
      state = $(".vis-options-physics-toggle").prop('checked');
      return window.visnetwork.setOptions({
        physics: state
      });
    });
    $('.all-settings').click(function(evt) {
      return $('#vis-config').dialog({
        title: 'Visualization Options',
        resizable: true,
        width: 500,
        height: 300
      });
    });
    $("#nodeLabelProperty").change(function() {
      return updateNodelabels();
    });
    updateNodelabels = function() {
      var key, nodes, selections;
      key = $("#nodeLabelProperty").val();
      Session.set('keyForNodeLabel', key);
      nodes = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
      window.visnetwork.stopSimulation();
      selections = (window.visnetwork.getSelection()).nodes;
      if (!selections.length) {
        nodes.forEach(function(node) {
          node.label = labelForVertex(node.element, key);
          return nodes.update({
            id: node.id,
            label: node.label
          });
        });
      } else {
        selections.forEach(function(nodeID) {
          var node;
          node = nodes.get(nodeID);
          node.label = labelForVertex(node.element, key);
          return nodes.update({
            id: node.id,
            label: node.label
          });
        });
      }
      return window.visnetwork.startSimulation();
    };
    $(".useLabelPrefix").prop('checked', true);
    Session.set('useLabelPrefix', true);
    $(".useLabelPrefix").change(function() {
      var state;
      state = $(".useLabelPrefix").prop('checked');
      Session.set('useLabelPrefix', state);
      return updateNodelabels();
    });
    $("#nodeLabelSelector").change(function() {
      var sel;
      sel = $("#nodeLabelSelector").val();
      if (sel === 'all vertices') {
        $('#elementSelector').val('{"type": "vertex"}');
      } else {
        if (sel === 'all edges') {
          $('#elementSelector').val('{"type": "edge"}');
        } else {
          $('#elementSelector').val('"' + $("#nodeLabelSelector").val() + '"');
        }
      }
      return $('#elementSelector').trigger('input');
    });
    Session.set('elementSelector', null);
    window.updateSelectedElements = function(ctxt) {
      var error, selectedEdges, selectedNodes, selector;
      Session.set('elementSelector', ctxt);
      try {
        selector = JSON.parse(Session.get('elementSelector'));
        $('#elementSelector')[0].style.color = 'black';
      } catch (error1) {
        error = error1;
        $('#elementSelector')[0].style.color = 'red';
        return;
      }
      selectedNodes = selectNodes(selector, window.visnetwork.body.data.nodes._data);
      selectedEdges = selectEdges(selector, window.visnetwork.body.data.edges._data);
      return window.visnetwork.setSelection({
        nodes: selectedNodes,
        edges: selectedEdges
      }, {
        unselectedAll: true,
        highlightEdges: false
      });
    };
    selectNodes = function(selector, possibles) {
      var each, f, found, j, key, l, len, len1, len2, len3, m, n, obj, possibleProps, possibleValues, props, ref, selected;
      selected = [];
      if (selector === null) {
        return selected;
      }
      if ($.isNumeric(selector) && possibles[selector]) {
        selected.push(selector);
        return selected;
      }
      if (_.isString(selector)) {
        selector = {
          label: selector
        };
      }
      if ($.isPlainObject(selector)) {
        possibleProps = (function() {
          var j, len, ref, results1;
          ref = _.values(possibles);
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            each = ref[j];
            results1.push({
              id: each.id,
              label: each.element.label,
              type: each.element.type,
              props: each.element.properties
            });
          }
          return results1;
        })();
        possibleValues = [];
        for (j = 0, len = possibleProps.length; j < len; j++) {
          props = possibleProps[j];
          obj = {
            id: props.id,
            label: props.label,
            type: props.type
          };
          ref = _.keys(props.props);
          for (l = 0, len1 = ref.length; l < len1; l++) {
            key = ref[l];
            obj[key] = props.props[key][0].value;
          }
          possibleValues.push(obj);
        }
        found = _.where(possibleValues, selector);
        for (m = 0, len2 = found.length; m < len2; m++) {
          f = found[m];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isArray(selector)) {
        for (n = 0, len3 = selector.length; n < len3; n++) {
          each = selector[n];
          selected.push(selectNodes(each, possibles));
        }
        selected = _.flatten(selected);
        return selected;
      }
      return selected;
    };
    selectEdges = function(selector, possibles) {
      var each, f, found, j, key, l, len, len1, len2, len3, len4, m, n, o, obj, possibleProps, possibleValues, props, ref, selected;
      selected = [];
      if (selector === null) {
        return selected;
      }
      if ($.isNumeric(selector) && possibles[selector]) {
        selected.push(selector);
        return selected;
      }
      if (_.isString(selector)) {
        selector = {
          label: selector
        };
      }
      if ($.isPlainObject(selector) === 232) {
        possibleValues = _.values(possibles);
        found = _.where(possibleValues, selector);
        for (j = 0, len = found.length; j < len; j++) {
          f = found[j];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isPlainObject(selector)) {
        possibleProps = (function() {
          var l, len1, ref, results1;
          ref = _.values(possibles);
          results1 = [];
          for (l = 0, len1 = ref.length; l < len1; l++) {
            each = ref[l];
            results1.push({
              id: each.id,
              label: each.element.label,
              type: each.element.type,
              props: (each.element.properties ? each.element.properties : {})
            });
          }
          return results1;
        })();
        possibleValues = [];
        for (l = 0, len1 = possibleProps.length; l < len1; l++) {
          props = possibleProps[l];
          obj = {
            id: props.id,
            label: props.label,
            type: 'edge'
          };
          ref = _.keys(props.props);
          for (m = 0, len2 = ref.length; m < len2; m++) {
            key = ref[m];
            obj[key] = props.props[key];
          }
          possibleValues.push(obj);
        }
        found = _.where(possibleValues, selector);
        for (n = 0, len3 = found.length; n < len3; n++) {
          f = found[n];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isArray(selector)) {
        for (o = 0, len4 = selector.length; o < len4; o++) {
          each = selector[o];
          selected.push(selectEdges(each, possibles));
        }
        selected = _.flatten(selected);
        return selected;
      }
      return selected;
    };
    return;
    $(".results-graph-fit").click(function() {
      return window.visnetwork.fit();
    });
    rect = {};
    drag = false;
    canvas = window.visnetwork.canvas.frame.canvas;
    ctx = canvas.getContext('2d');
    drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    saveDrawingSurface = function() {
      drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    };
    restoreDrawingSurface = function() {
      ctx.putImageData(drawingSurfaceImageData, 0, 0);
    };
    selectNodesFromHighlight = function() {
      var allNodes, curNode, i, nodePosition, nodeXY, nodesIdInDrawing, xRange, yRange;
      nodesIdInDrawing = Session.get('selectedNodes');
      xRange = getStartToEnd(rect.startX, rect.w);
      yRange = getStartToEnd(rect.startY, rect.h);
      allNodes = window.visnetwork.nodesHandler.body.data.nodes.get();
      i = 0;
      while (i < allNodes.length) {
        curNode = allNodes[i];
        nodePosition = window.visnetwork.getPositions([curNode.id]);
        nodeXY = window.visnetwork.canvasToDOM({
          x: nodePosition[curNode.id].x,
          y: nodePosition[curNode.id].y
        });
        if (xRange.start <= nodeXY.x && nodeXY.x <= xRange.end && yRange.start <= nodeXY.y && nodeXY.y <= yRange.end) {
          nodesIdInDrawing.push(curNode.id);
        }
        i++;
      }
      window.visnetwork.selectNodes(nodesIdInDrawing);
    };
    getStartToEnd = function(start, theLen) {
      var ret;
      if (theLen > 0) {
        ret = {
          start: start,
          end: start + theLen
        };
      } else {
        ret = {
          start: start + theLen,
          end: start
        };
      }
      return ret;
    };
    container = $("#mynetwork");
    container.on('mousemove', function(e) {
      if (drag) {
        restoreDrawingSurface();
        rect.w = e.pageX - this.offsetLeft - rect.startX;
        rect.h = e.pageY - this.offsetTop - rect.startY;
        ctx.setLineDash([5]);
        ctx.strokeStyle = 'rgb(0, 102, 0)';
        ctx.strokeRect(rect.startX, rect.startY, rect.w, rect.h);
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      }
    });
    container.on('mousedown', function(e) {
      var currentSelections, that;
      Session.set('selectedNodes', []);
      if (e.button === 2) {
        if (e.shiftKey) {
          currentSelections = window.visnetwork.getSelectedNodes();
          Session.set('selectedNodes', currentSelections);
        }
        saveDrawingSurface();
        that = this;
        rect.startX = e.pageX - this.offsetLeft;
        rect.startY = e.pageY - this.offsetTop;
        drag = true;
        container[0].style.cursor = 'crosshair';
      }
    });
    container.on('mouseup', function(e) {
      if (e.button === 2) {
        restoreDrawingSurface();
        drag = false;
        container[0].style.cursor = 'default';
        selectNodesFromHighlight();
      }
    });
    document.body.oncontextmenu = function() {
      return false;
    };
    $(".vis-options-node-hideShow").prop('checked', true);
    $(".vis-options-node-hideShow").change(function() {
      var newState, oldState;
      oldState = $(".vis-options-node-hideShow").prop('checked');
      newState = !oldState;
      return window.visnetwork.setOptions({
        nodes: {
          hidden: newState
        }
      });
    });
    $(".vis-options-edge-hideShow").prop('checked', true);
    $(".vis-options-edge-hideShow").change(function() {
      var newState, oldState;
      oldState = $(".vis-options-edge-hideShow").prop('checked');
      newState = !oldState;
      return window.visnetwork.setOptions({
        edges: {
          hidden: newState
        }
      });
    });
    $(".vis-options-physics-toggle").prop('checked', true);
    $(".vis-options-physics-toggle").change(function() {
      var state;
      state = $(".vis-options-physics-toggle").prop('checked');
      return window.visnetwork.setOptions({
        physics: state
      });
    });
    $('.all-settings').click(function(evt) {
      return $('#vis-config').dialog({
        title: 'Visualization Options',
        resizable: true,
        width: 500,
        height: 300
      });
    });
    $("#nodeLabelProperty").change(function() {
      return updateNodelabels();
    });
    updateNodelabels = function() {
      var key, nodes, selections;
      key = $("#nodeLabelProperty").val();
      Session.set('keyForNodeLabel', key);
      nodes = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
      window.visnetwork.stopSimulation();
      selections = (window.visnetwork.getSelection()).nodes;
      if (!selections.length) {
        nodes.forEach(function(node) {
          node.label = labelForVertex(node.element, key);
          return nodes.update({
            id: node.id,
            label: node.label
          });
        });
      } else {
        selections.forEach(function(nodeID) {
          var node;
          node = nodes.get(nodeID);
          node.label = labelForVertex(node.element, key);
          return nodes.update({
            id: node.id,
            label: node.label
          });
        });
      }
      return window.visnetwork.startSimulation();
    };
    $(".useLabelPrefix").prop('checked', true);
    Session.set('useLabelPrefix', true);
    $(".useLabelPrefix").change(function() {
      var state;
      state = $(".useLabelPrefix").prop('checked');
      Session.set('useLabelPrefix', state);
      return updateNodelabels();
    });
    $("#nodeLabelSelector").change(function() {
      $('#elementSelector').val('"' + $("#nodeLabelSelector").val() + '"');
      return $('#elementSelector').trigger('input');
    });
    Session.set('elementSelector', null);
    window.updateSelectedElements = function(ctxt) {
      var error, selectedEdges, selectedNodes, selector;
      Session.set('elementSelector', ctxt);
      try {
        selector = JSON.parse(Session.get('elementSelector'));
        $('#elementSelector')[0].style.color = 'black';
      } catch (error1) {
        error = error1;
        $('#elementSelector')[0].style.color = 'red';
        return;
      }
      selectedNodes = selectNodes(selector, window.visnetwork.body.data.nodes._data);
      selectedEdges = selectEdges(selector, window.visnetwork.body.data.edges._data);
      return window.visnetwork.setSelection({
        nodes: selectedNodes,
        edges: selectedEdges
      }, {
        unselectedAll: true,
        highlightEdges: false
      });
    };
    selectNodes = function(selector, possibles) {
      var each, f, found, j, key, l, len, len1, len2, len3, m, n, obj, possibleProps, possibleValues, props, ref, selected;
      selected = [];
      if (selector === null) {
        return selected;
      }
      if ($.isNumeric(selector) && possibles[selector]) {
        selected.push(selector);
        return selected;
      }
      if (_.isString(selector)) {
        selector = {
          label: selector
        };
      }
      if ($.isPlainObject(selector)) {
        possibleProps = (function() {
          var j, len, ref, results1;
          ref = _.values(possibles);
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            each = ref[j];
            results1.push({
              id: each.id,
              label: each.element.label,
              type: each.element.type,
              props: each.element.properties
            });
          }
          return results1;
        })();
        possibleValues = [];
        for (j = 0, len = possibleProps.length; j < len; j++) {
          props = possibleProps[j];
          obj = {
            id: props.id,
            label: props.label,
            type: props.type
          };
          ref = _.keys(props.props);
          for (l = 0, len1 = ref.length; l < len1; l++) {
            key = ref[l];
            obj[key] = props.props[key][0].value;
          }
          possibleValues.push(obj);
        }
        found = _.where(possibleValues, selector);
        for (m = 0, len2 = found.length; m < len2; m++) {
          f = found[m];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isArray(selector)) {
        for (n = 0, len3 = selector.length; n < len3; n++) {
          each = selector[n];
          selected.push(selectNodes(each, possibles));
        }
        selected = _.flatten(selected);
        return selected;
      }
      return selected;
    };
    selectEdges = function(selector, possibles) {
      var each, f, found, j, l, len, len1, possibleValues, selected;
      selected = [];
      if (selector === null) {
        return selected;
      }
      if ($.isNumeric(selector) && possibles[selector]) {
        selected.push(selector);
        return selected;
      }
      if (_.isString(selector)) {
        selector = {
          label: selector
        };
      }
      if ($.isPlainObject(selector)) {
        possibleValues = _.values(possibles);
        found = _.where(possibleValues, selector);
        for (j = 0, len = found.length; j < len; j++) {
          f = found[j];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isArray(selector)) {
        for (l = 0, len1 = selector.length; l < len1; l++) {
          each = selector[l];
          selected.push(selectEdges(each, possibles));
        }
        selected = _.flatten(selected);
        return selected;
      }
      return selected;
    };
  };

  processResults = function(results, success, queryTime) {
    var d;
    if (window.resultsEditor) {
      window.resultsEditor.set(results);
    }
    Session.set('scriptResult', results);
    Session.set('runStatus', success);
    d = moment.duration(Math.round(queryTime * 1000) / 1000);
    Session.set('queryTime', window.durationToString(d));
    d = moment.duration(Math.round((moment() - moment(Session.get('startTime'))) * 1000) / 1000);
    Session.set('elapsedTime', window.durationToString(d));
    determineGraphToShow();
    if (((Session.get('graphToShow')).nodes.length === 0) && ((Session.get('graphToShow')).edges.length === 0)) {
      Session.set('graphRenderingStatus', 'No graph in result');
    } else {
      Session.set('graphRenderingStatus', 'Ready');
      if (Session.get('drawGraphResult') === true) {
        Session.set('drawButtonPressed', true);
        Session.set('graphRenderingStatus', 'Rendering...');
        Session.set('elapsedRenderTime', 'Timing...');
        randomizeLayout();
        renderGraph();
      }
    }
  };

  selectNeighborsToAdd = function(currentSelectedNodeIDs, currentSelectedEdgeIDs, allV, allE) {
    var box;
    box = bootbox.dialog({
      title: 'Select neighboring vertices to add to local graph',
      message: 'hello',
      buttons: {
        confirm: {
          label: "Save",
          className: "btn-success",
          callback: function() {
            var each, j, label, labelVerts, len, nonSelectedNodeIds, ref, selectedVerts, verts2Visit;
            selectedVerts = [];
            verts2Visit = Session.get('verts2Visit');
            ref = Object.keys(verts2Visit);
            for (j = 0, len = ref.length; j < len; j++) {
              label = ref[j];
              labelVerts = _.reject(allV, function(node) {
                return node.label !== label;
              });
              selectedVerts = _.union(selectedVerts, _.sample(labelVerts, verts2Visit[label]));
            }
            currentSelectedNodeIDs = _.union(currentSelectedNodeIDs, (function() {
              var l, len1, results1;
              results1 = [];
              for (l = 0, len1 = selectedVerts.length; l < len1; l++) {
                each = selectedVerts[l];
                results1.push(each.id + "");
              }
              return results1;
            })());
            nonSelectedNodeIds = _.reject((function() {
              var l, len1, results1;
              results1 = [];
              for (l = 0, len1 = allV.length; l < len1; l++) {
                each = allV[l];
                results1.push(each.id + "");
              }
              return results1;
            })(), function(id) {
              return _.contains(currentSelectedNodeIDs, id);
            });
            allE = _.reject(allE, function(edge) {
              return _.contains(nonSelectedNodeIds, edge.inV + "") || _.contains(nonSelectedNodeIds, edge.outV + "");
            });
            return addInTheNeighbors(currentSelectedNodeIDs, currentSelectedEdgeIDs, selectedVerts, allE);
          }
        }
      }
    });
    box.find('.bootbox-body').remove();
    return Blaze.renderWithData(Template.VisitSelector, function() {
      return {
        allV: allV,
        allE: allE
      };
    }, box.find(".modal-body")[0]);
  };

  addInTheNeighbors = function(nodes2Select, edges2Select, allV, allE) {
    var ahe, ahn, e, edge, edges, j, l, len, len1, nodes, v, vert;
    ahn = allHiddenNodeIDs();
    allV = _.reject(allV, function(node) {
      return _.contains(ahn, node.id + "");
    });
    nodes = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = allV.length; j < len; j++) {
        v = allV[j];
        results1.push({
          id: String(v.id),
          label: labelForVertex(v, Session.get('keyForNodeLabel')),
          allowedToMoveX: true,
          allowedToMoveY: true,
          title: titleForElement(v),
          element: v
        });
      }
      return results1;
    })();
    window.visnetwork.nodesHandler.body.data.nodes.update(nodes);
    ahe = allHiddenEdgeIDs();
    allE = _.reject(allE, function(edge) {
      return _.contains(ahe, edge.id + "");
    });
    edges = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = allE.length; j < len; j++) {
        e = allE[j];
        results1.push({
          id: String(e.id),
          label: e.label,
          from: String(e.outV),
          to: String(e.inV),
          title: titleForElement(e),
          element: e
        });
      }
      return results1;
    })();
    window.visnetwork.edgesHandler.body.data.edges.update(edges);
    for (j = 0, len = nodes.length; j < len; j++) {
      vert = nodes[j];
      nodes2Select.push(vert.id);
    }
    for (l = 0, len1 = edges.length; l < len1; l++) {
      edge = edges[l];
      edges2Select.push(edge.id);
    }
    return window.visnetwork.setSelection({
      nodes: nodes2Select,
      edges: edges2Select
    });
  };

  scriptForGeneralIngestionFindOrCreate = function() {
    return '//given arrays of json for verts and edges, generate them into the graph\n//verts2FindOrCreate = incoming binding, an map of objects of properties to use to find existing vertices, or to create them if needed, keyed by fake vertID\n/* Example:   (needs to be a full description of the vertex in case we need to create it\n[\n    {label: "Sensor", id: 0, properties:{"sensorID": [{value: "v000000ktsmkitch"}]}}\n]\n*/\n//vertsJSON = incoming binding, an array of vertex-structured objects\n//edgesJSON = incoming binding, an array of edge-structured objects\n//transactionContext = incoming binding, string declaring purpose of graph transaction (comes out in Kafka topic "graphChange")\n\nif (bindings[\'vertsJSON\'] == null) {vertsJSON = []} else {vertsJSON = bindings[\'vertsJSON\']}\nif (bindings[\'edgesJSON\'] == null) {edgesJSON = []} else {edgesJSON = bindings[\'edgesJSON\']}\nif (bindings[\'verts2FindOrCreate\'] == null) {verts2FindOrCreate = []} else {verts2FindOrCreate = bindings[\'verts2FindOrCreate\']}\nif (bindings[\'transactionContext\'] == null) {transactionContext = "unlabeled transaction"} else {transactionContext = bindings[\'transactionContext\']}\n\nvMap = [:]\nvMapFull = [:]\neMapFull = [:]\nverts2FindOrCreate.collect { json ->\n    trav = g.V().hasLabel(json.label)\n    json.properties.each { key, val ->\n        trav = trav.has(key, val[0].value)\n        }\n    results = trav.toList()\n   if (results.size == 0) {oldV = null} else {oldV = results[0]}\n    if (oldV == null){\n        //create it\n        newV = gg(transactionContext).addV(json.label).next()\n        json.properties.each { key, val ->\n            gg(transactionContext).V(newV.id()).property(key, val[0].value).next()\n            }\n    } else {\n        //reference it\n        newV = oldV\n    }\n    vMap[json.id] = newV.id()\n\n}\n\n\nvertsJSON.collect { json ->\n    newV = gg(transactionContext).addV(json.label).next()\n    vMap[json.id] = newV.id()\n    vMapFull[json.id] = newV\n    json.properties.each { key, val ->\n        gg(transactionContext).V(newV.id()).property(key, val[0].value).next()\n}}\nedgesJSON.collect { json ->\n    fromID = vMap[json.outV] ? vMap[json.outV] : json.outV\n    toID = vMap[json.inV] ? vMap[json.inV] : json.inV\n    newEdge=gg(transactionContext).V(fromID).addE(json.label).to(g.V(toID)).next()\n    eMapFull[json.id] = newEdge\n    json.properties.collect { key, val ->\n        gg(transactionContext).E(newEdge.id()).property(key, val.value).next()\n}}\n//answer the maps of old element ids to new elements\n[vMap: vMap, vertMap: vMapFull, edgeMap: eMapFull]';
  };

}).call(this);

//# sourceMappingURL=ResultsVis.js.map
